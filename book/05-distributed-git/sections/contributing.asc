[[_contributing_project]]
=== Contribuyendo a un Proyecto

(((contributing)))
La principal dificultad con la descripción de cómo contribuir a un proyecto es que hay una gran cantidad de variaciones sobre cómo se hace.
Debido a que Git es muy flexible, las personas pueden y trabajan juntas de muchas maneras, y es problemático describir cómo debe contribuir: cada proyecto es un poco diferente.
Algunas de las variables involucradas son conteo de contribuyentes activos, flujo de trabajo elegido, acceso de confirmación y posiblemente el método de contribución externa.

La primera variable es el conteo de contribuyentes activos: ¿cuántos usuarios están contribuyendo activamente al código de este proyecto y con qué frecuencia?
En muchos casos, tendrá dos o tres desarrolladores con algunos commits por día, o posiblemente menos para proyectos un tanto inactivos.
Para empresas o proyectos más grandes, la cantidad de desarrolladores podría ser de miles, con cientos o miles de compromisos cada día.
Esto es importante porque con más y más desarrolladores, se encontrará con más problemas para asegurarse de que su código se aplique de forma limpia o se pueda fusionar fácilmente.
Los cambios que envíe pueden quedar obsoletos o severamente interrumpidos por el trabajo que se fusionó mientras estaba trabajando o mientras los cambios estaban esperando ser aprobados o aplicados.
¿Cómo puede mantener su código constantemente actualizado y sus confirmaciones válidas?

La siguiente variable es el flujo de trabajo en uso para el proyecto.
¿Está centralizado, con cada desarrollador teniendo el mismo acceso de escritura a la línea de código principal?
¿El proyecto tiene un mantenedor o un gerente de integración que verifica todos los parches?
¿Están todos los parches revisados por pares y aprobados?
¿Estás involucrado en ese proceso?
¿Hay un sistema de tenientes en su lugar, y tienes que enviar tu trabajo primero?

El siguiente problema es tu acceso de confirmación.
El flujo de trabajo requerido para contribuir a un proyecto es muy diferente si tiene acceso de escritura al proyecto que si no lo hace.
Si no tiene acceso de escritura, ¿cómo prefiere el proyecto aceptar el trabajo contribuido?
¿Incluso tiene una política?
¿Cuánto trabajo estás contribuyendo a la vez?
¿Con qué frecuencia contribuyes?

Todas estas preguntas pueden afectar la forma en que contribuye de manera efectiva a un proyecto y los flujos de trabajo preferidos o disponibles para usted.
Cubriremos aspectos de cada uno de estos en una serie de casos de uso, pasando de simples a más complejos; debería poder construir los flujos de trabajo específicos que necesita en la práctica a partir de estos ejemplos.

[[_commit_guidelines]]
==== Pautas de confirmación

Antes de comenzar a buscar casos de uso específicos, aquí hay una nota rápida sobre los mensajes de confirmación.
Tener una buena guía para crear compromisos y apegarse a ella hace que trabajar con Git y colaborar con otros sea mucho más fácil.
El proyecto Git proporciona un documento que presenta una serie de buenos consejos para crear compromisos a partir de los cuales enviar parches: puede leerlos en el código fuente de Git en el archivo `Documentation / SubmittingPatches`.

(((git commands, diff, check)))
En primer lugar, no desea enviar ningún error de espacios en blanco.
Git proporciona una manera fácil de verificar esto: antes de comprometerse, ejecute `git diff --check`, que identifica posibles errores de espacio en blanco y los enumera por usted.

.Output of `git diff --check`.
image::images/git-diff-check.png[Output of `git diff --check`.]

Si ejecuta ese comando antes de confirmar, puede ver si está a punto de cometer problemas de espacio en blanco que pueden molestar a otros desarrolladores.

A continuación, intente hacer que cada commit un conjunto de cambios lógicamente separado.
Si puede, trate de hacer que sus cambios sean digeribles: no codifique durante un fin de semana entero en cinco asuntos diferentes y luego envíelos todos como un compromiso masivo el lunes.
Incluso si no confirmas durante el fin de semana, utilice el área de etapas el lunes para dividir su trabajo en al menos una confirmación por cuestión, con un mensaje útil por confirmación.
Si algunos de los cambios modifican el mismo archivo, intente utilizar `git add --patch` para representar parcialmente los archivos (se detalla en << _ interactive_staging >>).
La instantánea del proyecto en la punta de la sucursal es idéntica ya sea que realice una confirmación o cinco, siempre que todos los cambios se agreguen en algún momento, así que trate de facilitar las cosas a sus compañeros desarrolladores cuando tengan que revisar sus cambios.
Este enfoque también hace que sea más fácil retirar o revertir uno de los conjuntos de cambios si lo necesita más adelante.
<< _ rewriting_history >> describe una serie de útiles trucos de Git para reescribir el historial y organizar de forma interactiva los archivos: use estas herramientas para crear un historial limpio y comprensible antes de enviar el trabajo a otra persona.

Lo último a tener en cuenta es el mensaje de compromiso.
Tener el hábito de crear mensajes de compromiso de calidad hace que usar y colaborar con Git sea mucho más fácil.
Como regla general, sus mensajes deben comenzar con una sola línea que no supere los 50 caracteres y que describa el conjunto de cambios de forma concisa, seguido de una línea en blanco, seguida de una explicación más detallada.
El proyecto Git requiere que la explicación más detallada incluya su motivación para el cambio y contraste su implementación con el comportamiento anterior: esta es una buena guía a seguir.
También es una buena idea usar el tiempo presente imperativo en estos mensajes.
En otras palabras, use comandos.
En lugar de `` agregué pruebas para '' o `` Añadir pruebas para '', use `` Agregar pruebas para ''.
Aquí hay una plantilla escrita originalmente por Tim Pope:

[source,text]
-----
Resumen de cambios cortos (50 caracteres o menos)

Texto explicativo más detallado, si es necesario. Ajustarlo a
aproximadamente 72 caracteres más o menos. En algunos contextos, el primero
línea se trata como el tema de un correo electrónico y el resto de
el texto como el cuerpo. La línea en blanco que separa el
resumen del cuerpo es crítico (a menos que omita el cuerpo
enteramente); herramientas como rebase pueden confundirse si ejecuta
los dos juntos.

Otros párrafos vienen después de las líneas en blanco.

  - Los puntos de viñetas también están bien

  - Típicamente se usa un guión o asterisco para la viñeta,
    precedido por un solo espacio, con líneas en blanco
    entre, pero las convenciones varían aquí
-----

Si todos sus mensajes de confirmación se ven así, las cosas serán mucho más fáciles para usted y para los desarrolladores con los que trabaja.
El proyecto Git tiene mensajes de confirmación bien formateados. Intenta ejecutar `git log --no-merges` allí para ver cómo se ve un historial de commit de proyecto muy bien formateado.

En los siguientes ejemplos, y en la mayor parte de este libro, en aras de la brevedad, este libro no tiene mensajes con un formato agradable como este; en cambio, usamos la opción `-m` para` git commit`.
Haz lo que decimos, no como lo hacemos.

[[_private_team]]
==== Pequeño equipo privado

(((contributing, private small team)))
La configuración más simple que es probable que encuentre es un proyecto privado con uno o dos desarrolladores más.
`` Privado '', en este contexto, significa fuente cerrada, no accesible para el mundo exterior.
Usted y los demás desarrolladores tienen acceso de inserción al repositorio.

In this environment, you can follow a workflow similar to what you might do when using Subversion or another centralized system.
You still get the advantages of things like offline committing and vastly simpler branching and merging, but the workflow can be very similar; the main difference is that merges happen client-side rather than on the server at commit time.
Let's see what it might look like when two developers start to work together with a shared repository.
The first developer, John, clones the repository, makes a change, and commits locally.
(The protocol messages have been replaced with `...` in these examples to shorten them somewhat.)

[source,console]
-----
# John's Machine
$ git clone john@githost:simplegit.git
Initialized empty Git repository in /home/john/simplegit/.git/
...
$ cd simplegit/
$ vim lib/simplegit.rb
$ git commit -am 'removed invalid default value'
[master 738ee87] removed invalid default value
 1 files changed, 1 insertions(+), 1 deletions(-)
-----

The second developer, Jessica, does the same thing – clones the repository and commits a change:

[source,console]
-----
# Jessica's Machine
$ git clone jessica@githost:simplegit.git
Initialized empty Git repository in /home/jessica/simplegit/.git/
...
$ cd simplegit/
$ vim TODO
$ git commit -am 'add reset task'
[master fbff5bc] add reset task
 1 files changed, 1 insertions(+), 0 deletions(-)
-----

Now, Jessica pushes her work up to the server:

[source,console]
-----
# Jessica's Machine
$ git push origin master
...
To jessica@githost:simplegit.git
   1edee6b..fbff5bc  master -> master
-----

John tries to push his change up, too:

[source,console]
-----
# John's Machine
$ git push origin master
To john@githost:simplegit.git
 ! [rejected]        master -> master (non-fast forward)
error: failed to push some refs to 'john@githost:simplegit.git'
-----

John isn't allowed to push because Jessica has pushed in the meantime.
This is especially important to understand if you're used to Subversion, because you'll notice that the two developers didn't edit the same file.
Although Subversion automatically does such a merge on the server if different files are edited, in Git you must merge the commits locally.
John has to fetch Jessica's changes and merge them in before he will be allowed to push:

[source,console]
-----
$ git fetch origin
...
From john@githost:simplegit
 + 049d078...fbff5bc master     -> origin/master
-----

At this point, John's local repository looks something like this:

.John's divergent history.
image::images/small-team-1.png[John's divergent history.]

John has a reference to the changes Jessica pushed up, but he has to merge them into his own work before he is allowed to push:

[source,console]
-----
$ git merge origin/master
Merge made by recursive.
 TODO |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)
-----

The merge goes smoothly – John's commit history now looks like this:

.John's repository after merging `origin/master`.
image::images/small-team-2.png[John's repository after merging `origin/master`.]

Now, John can test his code to make sure it still works properly, and then he can push his new merged work up to the server:

[source,console]
-----
$ git push origin master
...
To john@githost:simplegit.git
   fbff5bc..72bbc59  master -> master
-----

Finally, John's commit history looks like this:

.John's history after pushing to the `origin` server.
image::images/small-team-3.png[John's history after pushing to the `origin` server.]

In the meantime, Jessica has been working on a topic branch.
She's created a topic branch called `issue54` and done three commits on that branch.
She hasn't fetched John's changes yet, so her commit history looks like this:

.Jessica's topic branch.
image::images/small-team-4.png[Jessica's topic branch.]

Jessica wants to sync up with John, so she fetches:

[source,console]
-----
# Jessica's Machine
$ git fetch origin
...
From jessica@githost:simplegit
   fbff5bc..72bbc59  master     -> origin/master
-----

That pulls down the work John has pushed up in the meantime.
Jessica's history now looks like this:

.Jessica's history after fetching John's changes.
image::images/small-team-5.png[Jessica's history after fetching John's changes.]

Jessica thinks her topic branch is ready, but she wants to know what she has to merge into her work so that she can push.
She runs `git log` to find out:

[source,console]
-----
$ git log --no-merges issue54..origin/master
commit 738ee872852dfaa9d6634e0dea7a324040193016
Author: John Smith <jsmith@example.com>
Date:   Fri May 29 16:01:27 2009 -0700

   removed invalid default value
-----

The `issue54..origin/master` syntax is a log filter that asks Git to only show the list of commits that are on the latter branch (in this case `origin/master`) that are not on the first branch (in this case `issue54`). We'll go over this syntax in detail in <<_commit_ranges>>.

For now, we can see from the output that there is a single commit that John has made that Jessica has not merged in. If she merges `origin/master`, that is the single commit that will modify her local work.

Now, Jessica can merge her topic work into her master branch, merge John's work (`origin/master`) into her `master` branch, and then push back to the server again.
First, she switches back to her master branch to integrate all this work:

[source,console]
-----
$ git checkout master
Switched to branch 'master'
Your branch is behind 'origin/master' by 2 commits, and can be fast-forwarded.
-----

She can merge either `origin/master` or `issue54` first – they're both upstream, so the order doesn't matter.
The end snapshot should be identical no matter which order she chooses; only the history will be slightly different.
She chooses to merge in `issue54` first:

[source,console]
-----
$ git merge issue54
Updating fbff5bc..4af4298
Fast forward
 README           |    1 +
 lib/simplegit.rb |    6 +++++-
 2 files changed, 6 insertions(+), 1 deletions(-)
-----

No problems occur; as you can see it was a simple fast-forward.
Now Jessica merges in John's work (`origin/master`):

[source,console]
-----
$ git merge origin/master
Auto-merging lib/simplegit.rb
Merge made by recursive.
 lib/simplegit.rb |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)
-----

Everything merges cleanly, and Jessica's history looks like this:

.Jessica's history after merging John's changes.
image::images/small-team-6.png[Jessica's history after merging John's changes.]

Now `origin/master` is reachable from Jessica's `master` branch, so she should be able to successfully push (assuming John hasn't pushed again in the meantime):

[source,console]
-----
$ git push origin master
...
To jessica@githost:simplegit.git
   72bbc59..8059c15  master -> master
-----

Each developer has committed a few times and merged each other's work successfully.

.Jessica's history after pushing all changes back to the server.
image::images/small-team-7.png[Jessica's history after pushing all changes back to the server.]

That is one of the simplest workflows.
You work for a while, generally in a topic branch, and merge into your master branch when it's ready to be integrated.
When you want to share that work, you merge it into your own master branch, then fetch and merge `origin/master` if it has changed, and finally push to the `master` branch on the server.
The general sequence is something like this:

.General sequence of events for a simple multiple-developer Git workflow.
image::images/small-team-flow.png[General sequence of events for a simple multiple-developer Git workflow.]

==== Private Managed Team

(((contributing, private managed team)))
In this next scenario, you'll look at contributor roles in a larger private group.
You'll learn how to work in an environment where small groups collaborate on features and then those team-based contributions are integrated by another party.

Let's say that John and Jessica are working together on one feature, while Jessica and Josie are working on a second.
In this case, the company is using a type of integration-manager workflow where the work of the individual groups is integrated only by certain engineers, and the `master` branch of the main repo can be updated only by those engineers.
In this scenario, all work is done in team-based branches and pulled together by the integrators later.

Let's follow Jessica's workflow as she works on her two features, collaborating in parallel with two different developers in this environment.
Assuming she already has her repository cloned, she decides to work on `featureA` first.
She creates a new branch for the feature and does some work on it there:

[source,console]
-----
# Jessica's Machine
$ git checkout -b featureA
Switched to a new branch 'featureA'
$ vim lib/simplegit.rb
$ git commit -am 'add limit to log function'
[featureA 3300904] add limit to log function
 1 files changed, 1 insertions(+), 1 deletions(-)
-----

At this point, she needs to share her work with John, so she pushes her `featureA` branch commits up to the server.
Jessica doesn't have push access to the `master` branch – only the integrators do – so she has to push to another branch in order to collaborate with John:

[source,console]
-----
$ git push -u origin featureA
...
To jessica@githost:simplegit.git
 * [new branch]      featureA -> featureA
-----

Jessica e-mails John to tell him that she's pushed some work into a branch named `featureA` and he can look at it now.
While she waits for feedback from John, Jessica decides to start working on `featureB` with Josie.
To begin, she starts a new feature branch, basing it off the server's `master` branch:

[source,console]
-----
# Jessica's Machine
$ git fetch origin
$ git checkout -b featureB origin/master
Switched to a new branch 'featureB'
-----

Now, Jessica makes a couple of commits on the `featureB` branch:

[source,console]
-----
$ vim lib/simplegit.rb
$ git commit -am 'made the ls-tree function recursive'
[featureB e5b0fdc] made the ls-tree function recursive
 1 files changed, 1 insertions(+), 1 deletions(-)
$ vim lib/simplegit.rb
$ git commit -am 'add ls-files'
[featureB 8512791] add ls-files
 1 files changed, 5 insertions(+), 0 deletions(-)
-----

Jessica's repository looks like this:

.Jessica's initial commit history.
image::images/managed-team-1.png[Jessica's initial commit history.]

She's ready to push up her work, but gets an e-mail from Josie that a branch with some initial work on it was already pushed to the server as `featureBee`.
Jessica first needs to merge those changes in with her own before she can push to the server.
She can then fetch Josie's changes down with `git fetch`:

[source,console]
-----
$ git fetch origin
...
From jessica@githost:simplegit
 * [new branch]      featureBee -> origin/featureBee
-----

Jessica can now merge this into the work she did with `git merge`:

[source,console]
-----
$ git merge origin/featureBee
Auto-merging lib/simplegit.rb
Merge made by recursive.
 lib/simplegit.rb |    4 ++++
 1 files changed, 4 insertions(+), 0 deletions(-)
-----

There is a bit of a problem – she needs to push the merged work in her `featureB` branch to the `featureBee` branch on the server.
She can do so by specifying the local branch followed by a colon (:) followed by the remote branch to the `git push` command:

[source,console]
-----
$ git push -u origin featureB:featureBee
...
To jessica@githost:simplegit.git
   fba9af8..cd685d1  featureB -> featureBee
-----

This is called a _refspec_.
See <<_refspec>> for a more detailed discussion of Git refspecs and different things you can do with them.
Also notice the `-u` flag; this is short for `--set-upstream`, which configures the branches for easier pushing and pulling later.

Next, John e-mails Jessica to say he's pushed some changes to the `featureA` branch and asks her to verify them.
She runs a `git fetch` to pull down those changes:

[source,console]
-----
$ git fetch origin
...
From jessica@githost:simplegit
   3300904..aad881d  featureA   -> origin/featureA
-----

Then, she can see what has been changed with `git log`:

[source,console]
-----
$ git log featureA..origin/featureA
commit aad881d154acdaeb2b6b18ea0e827ed8a6d671e6
Author: John Smith <jsmith@example.com>
Date:   Fri May 29 19:57:33 2009 -0700

    changed log output to 30 from 25
-----

Finally, she merges John's work into her own `featureA` branch:

[source,console]
-----
$ git checkout featureA
Switched to branch 'featureA'
$ git merge origin/featureA
Updating 3300904..aad881d
Fast forward
 lib/simplegit.rb |   10 +++++++++-
1 files changed, 9 insertions(+), 1 deletions(-)
-----

Jessica wants to tweak something, so she commits again and then pushes this back up to the server:

[source,console]
-----
$ git commit -am 'small tweak'
[featureA 774b3ed] small tweak
 1 files changed, 1 insertions(+), 1 deletions(-)
$ git push
...
To jessica@githost:simplegit.git
   3300904..774b3ed  featureA -> featureA
-----

Jessica's commit history now looks something like this:

.Jessica's history after committing on a feature branch.
image::images/managed-team-2.png[Jessica's history after committing on a feature branch.]

Jessica, Josie, and John inform the integrators that the `featureA` and `featureBee` branches on the server are ready for integration into the mainline.
After the integrators merge these branches into the mainline, a fetch will bring down the new merge commit, making the history look like this:

.Jessica's history after merging both her topic branches.
image::images/managed-team-3.png[Jessica's history after merging both her topic branches.]

Many groups switch to Git because of this ability to have multiple teams working in parallel, merging the different lines of work late in the process.
The ability of smaller subgroups of a team to collaborate via remote branches without necessarily having to involve or impede the entire team is a huge benefit of Git.
The sequence for the workflow you saw here is something like this:

.Basic sequence of this managed-team workflow.
image::images/managed-team-flow.png[Basic sequence of this managed-team workflow.]

[[_public_project]]
==== Forked Public Project

(((contributing, public small project)))
Contributing to public projects is a bit different.
Because you don't have the permissions to directly update branches on the project, you have to get the work to the maintainers some other way.
This first example describes contributing via forking on Git hosts that support easy forking.
Many hosting sites support this (including GitHub, BitBucket, Google Code, repo.or.cz, and others), and many project maintainers expect this style of contribution.
The next section deals with projects that prefer to accept contributed patches via e-mail.

First, you'll probably want to clone the main repository, create a topic branch for the patch or patch series you're planning to contribute, and do your work there.
The sequence looks basically like this:

[source,console]
-----
$ git clone (url)
$ cd project
$ git checkout -b featureA
# (work)
$ git commit
# (work)
$ git commit
-----

[NOTE]
====
You may want to use `rebase -i` to squash your work down to a single commit, or rearrange the work in the commits to make the patch easier for the maintainer to review – see <<_rewriting_history>> for more information about interactive rebasing.
====

When your branch work is finished and you're ready to contribute it back to the maintainers, go to the original project page and click the ``Fork'' button, creating your own writable fork of the project.
You then need to add in this new repository URL as a second remote, in this case named `myfork`:

[source,console]
-----
$ git remote add myfork (url)
-----

Then you need to push your work up to it.
It's easiest to push the topic branch you're working on up to your repository, rather than merging into your master branch and pushing that up.
The reason is that if the work isn't accepted or is cherry picked, you don't have to rewind your master branch.
If the maintainers merge, rebase, or cherry-pick your work, you'll eventually get it back via pulling from their repository anyhow:

[source,console]
-----
$ git push -u myfork featureA
-----

(((git commands, request-pull)))
When your work has been pushed up to your fork, you need to notify the maintainer.
This is often called a pull request, and you can either generate it via the website – GitHub has its own Pull Request mechanism that we'll go over in <<_github>> – or you can run the `git request-pull` command and e-mail the output to the project maintainer manually.

The `request-pull` command takes the base branch into which you want your topic branch pulled and the Git repository URL you want them to pull from, and outputs a summary of all the changes you're asking to be pulled in.
For instance, if Jessica wants to send John a pull request, and she's done two commits on the topic branch she just pushed up, she can run this:

[source,console]
-----
$ git request-pull origin/master myfork
The following changes since commit 1edee6b1d61823a2de3b09c160d7080b8d1b3a40:
  John Smith (1):
        added a new function

are available in the git repository at:

  git://githost/simplegit.git featureA

Jessica Smith (2):
      add limit to log function
      change log output to 30 from 25

 lib/simplegit.rb |   10 +++++++++-
 1 files changed, 9 insertions(+), 1 deletions(-)
-----

The output can be sent to the maintainer–it tells them where the work was branched from, summarizes the commits, and tells where to pull this work from.

On a project for which you're not the maintainer, it's generally easier to have a branch like `master` always track `origin/master` and to do your work in topic branches that you can easily discard if they're rejected.
Having work themes isolated into topic branches also makes it easier for you to rebase your work if the tip of the main repository has moved in the meantime and your commits no longer apply cleanly.
For example, if you want to submit a second topic of work to the project, don't continue working on the topic branch you just pushed up – start over from the main repository's `master` branch:

[source,console]
-----
$ git checkout -b featureB origin/master
# (work)
$ git commit
$ git push myfork featureB
# (email maintainer)
$ git fetch origin
-----

Now, each of your topics is contained within a silo – similar to a patch queue – that you can rewrite, rebase, and modify without the topics interfering or interdepending on each other, like so:

.Initial commit history with `featureB` work.
image::images/public-small-1.png[Initial commit history with `featureB` work.]

Let's say the project maintainer has pulled in a bunch of other patches and tried your first branch, but it no longer cleanly merges.
In this case, you can try to rebase that branch on top of `origin/master`, resolve the conflicts for the maintainer, and then resubmit your changes:

[source,console]
-----
$ git checkout featureA
$ git rebase origin/master
$ git push -f myfork featureA
-----

This rewrites your history to now look like <<psp_b>>.

[[psp_b]]
.Commit history after `featureA` work.
image::images/public-small-2.png[Commit history after `featureA` work.]

Because you rebased the branch, you have to specify the `-f` to your push command in order to be able to replace the `featureA` branch on the server with a commit that isn't a descendant of it.
An alternative would be to push this new work to a different branch on the server (perhaps called `featureAv2`).

Let's look at one more possible scenario: the maintainer has looked at work in your second branch and likes the concept but would like you to change an implementation detail.
You'll also take this opportunity to move the work to be based off the project's current `master` branch.
You start a new branch based off the current `origin/master` branch, squash the `featureB` changes there, resolve any conflicts, make the implementation change, and then push that up as a new branch:

(((git commands, merge, squash)))
[source,console]
-----
$ git checkout -b featureBv2 origin/master
$ git merge --no-commit --squash featureB
# (change implementation)
$ git commit
$ git push myfork featureBv2
-----

La opción `--squash` toma todo el trabajo en la rama fusionada y lo aplasta en una confirmación sin fusión en la parte superior de la rama en la que se encuentra.
La opción `--no-commit` le dice a Git que no registre automáticamente una confirmación.
Esto le permite introducir todos los cambios desde otra rama y luego realizar más cambios antes de registrar la nueva confirmación.

Ahora puede enviar al mantenedor un mensaje de que ha realizado los cambios solicitados y puede encontrar esos cambios en su rama `featureBv2`.

.Commit history after `featureBv2` work.
image::images/public-small-3.png[Commit history after `featureBv2` work.]

[[_project_over_email]]
==== Proyecto público a través de correo electrónico

(((contributing, public large project)))
Muchos proyectos han establecido procedimientos para aceptar parches: deberá verificar las reglas específicas para cada proyecto, ya que serán diferentes.
Dado que hay varios proyectos antiguos y más grandes que aceptan parches a través de una lista de correo electrónico para desarrolladores, veremos un ejemplo de eso ahora.

El flujo de trabajo es similar al caso de uso anterior: crea ramas de tema para cada serie de parches en las que trabaja.
La diferencia es cómo los envías al proyecto.
En lugar de bifurcar el proyecto y avanzar hacia su propia versión de escritura, genera versiones de correo electrónico de cada serie de commit y las envía por correo electrónico a la lista de correo de desarrolladores:

[source,console]
-----
$ git checkout -b topicA
# (work)
$ git commit
# (work)
$ git commit
-----

(((git commands, format-patch)))
Ahora tiene dos confirmaciones que desea enviar a la lista de correo.
Utiliza `git format-patch` para generar los archivos con formato mbox que puedes enviar por correo electrónico a la lista: convierte cada confirmación en un mensaje de correo electrónico con la primera línea del mensaje de confirmación como tema y el resto de el mensaje más el parche que introduce el compromiso como el cuerpo.
Lo bueno de esto es que la aplicación de un parche de un correo electrónico generado con `format-patch` conserva toda la información de compromiso correctamente.

[source,console]
-----
$ git format-patch -M origin/master
0001-add-limit-to-log-function.patch
0002-changed-log-output-to-30-from-25.patch
-----

El comando `format-patch` imprime los nombres de los archivos de parche que crea.
El modificador `-M` le dice a Git que busque cambios de nombre.
Los archivos terminan pareciéndose a esto:

[source,console]
-----
$ cat 0001-add-limit-to-log-function.patch
From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001
From: Jessica Smith <jessica@example.com>
Date: Sun, 6 Apr 2008 10:17:23 -0700
Subject: [PATCH 1/2] add limit to log function

Limit log functionality to the first 20

---
 lib/simplegit.rb |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index 76f47bc..f9815f1 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -14,7 +14,7 @@ class SimpleGit
   end

   def log(treeish = 'master')
-    command("git log #{treeish}")
+    command("git log -n 20 #{treeish}")
   end

   def ls_tree(treeish = 'master')
--
2.1.0
-----

También puede editar estos archivos de parche para agregar más información para la lista de correo electrónico que no desea mostrar en el mensaje de confirmación.
Si agrega texto entre la línea `---` y el comienzo del parche (la línea `diff - git`), los desarrolladores pueden leerlo; pero aplicar el parche lo excluye.

Para enviarlo por correo electrónico a una lista de correo, puede pegar el archivo en su programa de correo electrónico o enviarlo a través de un programa de línea de comandos.
Pegar el texto a menudo causa problemas de formateo, especialmente con clientes `` más inteligentes '' que no conservan líneas nuevas y otros espacios en blanco de manera apropiada.
Afortunadamente, Git proporciona una herramienta para ayudarlo a enviar parches con formato correcto a través de IMAP, que puede ser más fácil para usted.
Demostraremos cómo enviar un parche a través de Gmail, que es el agente de correo electrónico que mejor conocemos; puede leer instrucciones detalladas para una cantidad de programas de correo al final del archivo `Documentation / SubmittingPatches` antes mencionado en el código fuente de Git.

(((git commands, config)))(((email)))
Primero, necesitas configurar la sección imap en tu archivo `~ / .gitconfig`.
Puede establecer cada valor por separado con una serie de comandos `git config`, o puede agregarlos manualmente, pero al final su archivo de configuración debería verse más o menos así:

[source,ini]
-----
[imap]
  folder = "[Gmail]/Drafts"
  host = imaps://imap.gmail.com
  user = user@gmail.com
  pass = p4ssw0rd
  port = 993
  sslverify = false
-----

Si su servidor IMAP no usa SSL, las dos últimas líneas probablemente no sean necesarias, y el valor del host será `imap: //` en lugar de `imaps: //`.
Cuando esté configurado, puede usar `git send-email` para colocar la serie de parches en la carpeta Borradores del servidor IMAP especificado:

[source,console]
-----
$ git send-email *.patch
0001-added-limit-to-log-function.patch
0002-changed-log-output-to-30-from-25.patch
Who should the emails appear to be from? [Jessica Smith <jessica@example.com>]
Emails will be sent from: Jessica Smith <jessica@example.com>
Who should the emails be sent to? jessica@example.com
Message-ID to be used as In-Reply-To for the first email? y
-----

Entonces, Git escupe un montón de información de registro que se ve algo así para cada parche que estás enviando:

[source,text]
-----
(mbox) Adding cc: Jessica Smith <jessica@example.com> from
  \line 'From: Jessica Smith <jessica@example.com>'
OK. Log says:
Sendmail: /usr/sbin/sendmail -i jessica@example.com
From: Jessica Smith <jessica@example.com>
To: jessica@example.com
Subject: [PATCH 1/2] added limit to log function
Date: Sat, 30 May 2009 13:29:15 -0700
Message-Id: <1243715356-61726-1-git-send-email-jessica@example.com>
X-Mailer: git-send-email 1.6.2.rc1.20.g8c5b.dirty
In-Reply-To: <y>
References: <y>

Result: OK
-----

En este punto, debe poder ir a la carpeta Borradores, cambiar el campo A a la lista de correo a la que le envía el parche, posiblemente CC al responsable o a la persona responsable de esa sección, y enviarlo.

==== Resumen

Esta sección ha cubierto una cantidad de flujos de trabajo comunes para tratar con varios tipos muy diferentes de proyectos de Git que probablemente encuentre, e introdujo algunas herramientas nuevas para ayudarlo a administrar este proceso.
A continuación, verá cómo trabajar la otra cara de la moneda: mantener un proyecto de Git.
Aprenderá cómo ser un dictador benevolente o un gerente de integración.
