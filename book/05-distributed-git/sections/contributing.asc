[[_contributing_project]]
=== Contribuyendo a un Proyecto

(((contributing)))
La principal dificultad con la descripción de cómo contribuir a un proyecto es que hay una gran cantidad de variaciones sobre cómo se hace.
Debido a que Git es muy flexible, las personas pueden y trabajan juntas de muchas maneras, y es problemático describir cómo debe contribuir: cada proyecto es un poco diferente.
Algunas de las variables involucradas son conteo de contribuyentes activos, flujo de trabajo elegido, acceso de confirmación y posiblemente el método de contribución externa.

La primera variable es el conteo de contribuyentes activos: ¿cuántos usuarios están contribuyendo activamente al código de este proyecto y con qué frecuencia?
En muchos casos, tendrá dos o tres desarrolladores con algunos commits por día, o posiblemente menos para proyectos un tanto inactivos.
Para empresas o proyectos más grandes, la cantidad de desarrolladores podría ser de miles, con cientos o miles de compromisos cada día.
Esto es importante porque con más y más desarrolladores, se encontrará con más problemas para asegurarse de que su código se aplique de forma limpia o se pueda fusionar fácilmente.
Los cambios que envíe pueden quedar obsoletos o severamente interrumpidos por el trabajo que se fusionó mientras estaba trabajando o mientras los cambios estaban esperando ser aprobados o aplicados.
¿Cómo puede mantener su código constantemente actualizado y sus confirmaciones válidas?

La siguiente variable es el flujo de trabajo en uso para el proyecto.
¿Está centralizado, con cada desarrollador teniendo el mismo acceso de escritura a la línea de código principal?
¿El proyecto tiene un mantenedor o un gerente de integración que verifica todos los parches?
¿Están todos los parches revisados por pares y aprobados?
¿Estás involucrado en ese proceso?
¿Hay un sistema de tenientes en su lugar, y tienes que enviar tu trabajo primero?

El siguiente problema es tu acceso de confirmación.
El flujo de trabajo requerido para contribuir a un proyecto es muy diferente si tiene acceso de escritura al proyecto que si no lo hace.
Si no tiene acceso de escritura, ¿cómo prefiere el proyecto aceptar el trabajo contribuido?
¿Incluso tiene una política?
¿Cuánto trabajo estás contribuyendo a la vez?
¿Con qué frecuencia contribuyes?

Todas estas preguntas pueden afectar la forma en que contribuye de manera efectiva a un proyecto y los flujos de trabajo preferidos o disponibles para usted.
Cubriremos aspectos de cada uno de estos en una serie de casos de uso, pasando de simples a más complejos; debería poder construir los flujos de trabajo específicos que necesita en la práctica a partir de estos ejemplos.

[[_commit_guidelines]]
==== Pautas de confirmación

Antes de comenzar a buscar casos de uso específicos, aquí hay una nota rápida sobre los mensajes de confirmación.
Tener una buena guía para crear compromisos y apegarse a ella hace que trabajar con Git y colaborar con otros sea mucho más fácil.
El proyecto Git proporciona un documento que presenta una serie de buenos consejos para crear compromisos a partir de los cuales enviar parches: puede leerlos en el código fuente de Git en el archivo `Documentation / SubmittingPatches`.

(((git commands, diff, check)))
En primer lugar, no desea enviar ningún error de espacios en blanco.
Git proporciona una manera fácil de verificar esto: antes de comprometerse, ejecute `git diff --check`, que identifica posibles errores de espacio en blanco y los enumera por usted.

.Output of `git diff --check`.
image::images/git-diff-check.png[Output of `git diff --check`.]

Si ejecuta ese comando antes de confirmar, puede ver si está a punto de cometer problemas de espacio en blanco que pueden molestar a otros desarrolladores.

A continuación, intente hacer que cada commit un conjunto de cambios lógicamente separado.
Si puede, trate de hacer que sus cambios sean digeribles: no codifique durante un fin de semana entero en cinco asuntos diferentes y luego envíelos todos como un compromiso masivo el lunes.
Incluso si no confirmas durante el fin de semana, utilice el área de etapas el lunes para dividir su trabajo en al menos una confirmación por cuestión, con un mensaje útil por confirmación.
Si algunos de los cambios modifican el mismo archivo, intente utilizar `git add --patch` para representar parcialmente los archivos (se detalla en << _ interactive_staging >>).
La instantánea del proyecto en la punta de la sucursal es idéntica ya sea que realice una confirmación o cinco, siempre que todos los cambios se agreguen en algún momento, así que trate de facilitar las cosas a sus compañeros desarrolladores cuando tengan que revisar sus cambios.
Este enfoque también hace que sea más fácil retirar o revertir uno de los conjuntos de cambios si lo necesita más adelante.
<< _ rewriting_history >> describe una serie de útiles trucos de Git para reescribir el historial y organizar de forma interactiva los archivos: use estas herramientas para crear un historial limpio y comprensible antes de enviar el trabajo a otra persona.

Lo último a tener en cuenta es el mensaje de compromiso.
Tener el hábito de crear mensajes de compromiso de calidad hace que usar y colaborar con Git sea mucho más fácil.
Como regla general, sus mensajes deben comenzar con una sola línea que no supere los 50 caracteres y que describa el conjunto de cambios de forma concisa, seguido de una línea en blanco, seguida de una explicación más detallada.
El proyecto Git requiere que la explicación más detallada incluya su motivación para el cambio y contraste su implementación con el comportamiento anterior: esta es una buena guía a seguir.
También es una buena idea usar el tiempo presente imperativo en estos mensajes.
En otras palabras, use comandos.
En lugar de `` agregué pruebas para '' o `` Añadir pruebas para '', use `` Agregar pruebas para ''.
Aquí hay una plantilla escrita originalmente por Tim Pope:

[source,text]
-----
Resumen de cambios cortos (50 caracteres o menos)

Texto explicativo más detallado, si es necesario. Ajustarlo a
aproximadamente 72 caracteres más o menos. En algunos contextos, el primero
línea se trata como el tema de un correo electrónico y el resto de
el texto como el cuerpo. La línea en blanco que separa el
resumen del cuerpo es crítico (a menos que omita el cuerpo
enteramente); herramientas como rebase pueden confundirse si ejecuta
los dos juntos.

Otros párrafos vienen después de las líneas en blanco.

  - Los puntos de viñetas también están bien

  - Típicamente se usa un guión o asterisco para la viñeta,
    precedido por un solo espacio, con líneas en blanco
    entre, pero las convenciones varían aquí
-----

Si todos sus mensajes de confirmación se ven así, las cosas serán mucho más fáciles para usted y para los desarrolladores con los que trabaja.
El proyecto Git tiene mensajes de confirmación bien formateados. Intenta ejecutar `git log --no-merges` allí para ver cómo se ve un historial de commit de proyecto muy bien formateado.

En los siguientes ejemplos, y en la mayor parte de este libro, en aras de la brevedad, este libro no tiene mensajes con un formato agradable como este; en cambio, usamos la opción `-m` para` git commit`.
Haz lo que decimos, no como lo hacemos.

[[_private_team]]
==== Pequeño equipo privado

(((contributing, private small team)))
La configuración más simple que es probable que encuentre es un proyecto privado con uno o dos desarrolladores más.
`` Privado '', en este contexto, significa fuente cerrada, no accesible para el mundo exterior.
Usted y los demás desarrolladores tienen acceso de inserción al repositorio.

En este entorno, puede seguir un flujo de trabajo similar a lo que podría hacer al usar Subversion u otro sistema centralizado.
Aún obtiene las ventajas de cosas como el compromiso fuera de línea y una bifurcación y fusión mucho más simples, pero el flujo de trabajo puede ser muy similar; la principal diferencia es que las fusiones ocurren en el lado del cliente en lugar de en el servidor en el momento de la confirmación.
Veamos cómo se vería cuando dos desarrolladores comiencen a trabajar junto con un repositorio compartido.
El primer desarrollador, John, clona el repositorio, hace un cambio y se compromete localmente.
(Los mensajes de protocolo se han reemplazado con `...` en estos ejemplos para acortarlos un poco).

[source,console]
-----
# John's Machine
$ git clone john@githost:simplegit.git
Initialized empty Git repository in /home/john/simplegit/.git/
...
$ cd simplegit/
$ vim lib/simplegit.rb
$ git commit -am 'removed invalid default value'
[master 738ee87] removed invalid default value
 1 files changed, 1 insertions(+), 1 deletions(-)
-----

El segundo desarrollador, Jessica, hace lo mismo: clona el repositorio y comete un cambio:

[source,console]
-----
# Jessica's Machine
$ git clone jessica@githost:simplegit.git
Initialized empty Git repository in /home/jessica/simplegit/.git/
...
$ cd simplegit/
$ vim TODO
$ git commit -am 'add reset task'
[master fbff5bc] add reset task
 1 files changed, 1 insertions(+), 0 deletions(-)
-----

Ahora, Jessica lleva su trabajo al servidor:

[source,console]
-----
# Jessica's Machine
$ git push origin master
...
To jessica@githost:simplegit.git
   1edee6b..fbff5bc  master -> master
-----

John intenta impulsar su cambio, también:

[source,console]
-----
# John's Machine
$ git push origin master
To john@githost:simplegit.git
 ! [rejected]        master -> master (non-fast forward)
error: failed to push some refs to 'john@githost:simplegit.git'
-----

John no puede presionar porque Jessica ha presionado mientras tanto.
Esto es especialmente importante para entender si está acostumbrado a Subversion, porque notará que los dos desarrolladores no editaron el mismo archivo.
Aunque Subversion realiza automáticamente una fusión de este tipo en el servidor si se editan diferentes archivos, en Git debe fusionar los commit localmente.
John tiene que buscar los cambios de Jessica y fusionarlos antes de que se le permita presionar:

[source,console]
-----
$ git fetch origin
...
From john@githost:simplegit
 + 049d078...fbff5bc master     -> origin/master
-----

En este punto, el repositorio local de John se ve así:

.John's divergent history.
image::images/small-team-1.png[John's divergent history.]

John tiene una referencia a los cambios que Jessica elevó, pero tiene que fusionarlos en su propio trabajo antes de que se le permita presionar:

[source,console]
-----
$ git merge origin/master
Merge made by recursive.
 TODO |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)
-----

La fusión funciona sin problemas: el historial de compromisos de John ahora se ve así:

.John's repository after merging `origin/master`.
image::images/small-team-2.png[John's repository after merging `origin/master`.]

Ahora, John puede probar su código para asegurarse de que todavía funciona correctamente, y luego puede enviar su nuevo trabajo combinado al servidor:

[source,console]
-----
$ git push origin master
...
To john@githost:simplegit.git
   fbff5bc..72bbc59  master -> master
-----

Finalmente, el historial de compromisos de John se ve así:

.John's history after pushing to the `origin` server.
image::images/small-team-3.png[John's history after pushing to the `origin` server.]

Mientras tanto, Jessica ha estado trabajando en una rama temática.
Ella creó una rama temática llamada `issue54` y realizó tres commits en esa rama.
Todavía no ha revisado los cambios de John, por lo que su historial de commit se ve así:

.Jessica's topic branch.
image::images/small-team-4.png[Jessica's topic branch.]

Jessica quiere sincronizar con John, así que busca:

[source,console]
-----
# Jessica's Machine
$ git fetch origin
...
From jessica@githost:simplegit
   fbff5bc..72bbc59  master     -> origin/master
-----

Eso reduce el trabajo que John ha impulsado mientras tanto.
La historia de Jessica ahora se ve así:

.Jessica's history after fetching John's changes.
image::images/small-team-5.png[Jessica's history after fetching John's changes.]

Jessica cree que su rama temática está lista, pero quiere saber qué tiene que fusionar en su trabajo para poder impulsarla.
Ella ejecuta `git log` para descubrir:

[source,console]
-----
$ git log --no-merges issue54..origin/master
commit 738ee872852dfaa9d6634e0dea7a324040193016
Author: John Smith <jsmith@example.com>
Date:   Fri May 29 16:01:27 2009 -0700

   removed invalid default value
-----

La sintaxis `issue54..origin / master` es un filtro de registro que le pide a Git que solo muestre la lista de confirmaciones que están en la última rama (en este caso` origen / maestro`) que no están en la primera rama (en este case `issue54`). Repasaremos esta sintaxis en detalle en << _ commit_ranges >>.

Por ahora, podemos ver en el resultado que hay un compromiso único que John ha realizado y en el que Jessica no se ha fusionado. Si fusiona `origen / maestro`, esa es la única confirmación que modificará su trabajo local.

Ahora, Jessica puede fusionar su trabajo temático en su rama principal, fusionar el trabajo de John (`origin / master`) en su rama` master`, y luego volver al servidor nuevamente.
Primero, vuelve a su rama principal para integrar todo este trabajo:

[source,console]
-----
$ git checkout master
Switched to branch 'master'
Your branch is behind 'origin/master' by 2 commits, and can be fast-forwarded.
-----

Ella puede fusionar ya sea `origin / master` o` issue54` primero - ambos están en sentido ascendente, por lo que el orden no importa.
La instantánea final debe ser idéntica sin importar qué orden ella elija; solo la historia será ligeramente diferente.
Ella elige fusionarse en `issue54` primero:

[source,console]
-----
$ git merge issue54
Updating fbff5bc..4af4298
Fast forward
 README           |    1 +
 lib/simplegit.rb |    6 +++++-
 2 files changed, 6 insertions(+), 1 deletions(-)
-----

No hay problemas como pueden ver, fue un simple avance rápido.
Ahora Jessica se fusiona en el trabajo de John (`origin / master`):

[source,console]
-----
$ git merge origin/master
Auto-merging lib/simplegit.rb
Merge made by recursive.
 lib/simplegit.rb |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)
-----

Todo se funde limpiamente, y la historia de Jessica se ve así:

.Jessica's history after merging John's changes.
image::images/small-team-6.png[Jessica's history after merging John's changes.]

Ahora `origin / master` es accesible desde la rama` master` de Jessica, por lo que debería poder presionar con éxito (suponiendo que John no haya pulsado nuevamente mientras tanto):

[source,console]
-----
$ git push origin master
...
To jessica@githost:simplegit.git
   72bbc59..8059c15  master -> master
-----

Cada desarrollador se ha comprometido algunas veces y se ha fusionado el trabajo de cada uno con éxito.

.Jessica's history after pushing all changes back to the server.
image::images/small-team-7.png[Jessica's history after pushing all changes back to the server.]

Ese es uno de los flujos de trabajo más simples.
Trabajas por un tiempo, generalmente en una rama temática, y te unes a tu rama principal cuando está lista para integrarse.
Cuando desee compartir ese trabajo, hágalo en su propia rama principal, luego busque y combine `origin / master` si ha cambiado, y finalmente presione en la rama` master` en el servidor.
La secuencia general es algo como esto:

.General sequence of events for a simple multiple-developer Git workflow.
image::images/small-team-flow.png[General sequence of events for a simple multiple-developer Git workflow.]

==== Equipo privado administrado

(((contributing, private managed team)))
En este próximo escenario, observará los roles de los contribuyentes en un grupo privado más grande.
Aprenderá cómo trabajar en un entorno en el que los grupos pequeños colaboran en las funciones y luego esas contribuciones en equipo estarán integradas por otra parte.

Digamos que John y Jessica están trabajando juntos en una característica, mientras que Jessica y Josie están trabajando en una segunda.
En este caso, la compañía está utilizando un tipo de flujo de trabajo de integración-gerente donde el trabajo de los grupos individuales está integrado solo por ciertos ingenieros, y la rama `maestra` del repositorio principal solo puede ser actualizada por esos ingenieros.
En este escenario, todo el trabajo se realiza en sucursales basadas en equipos y luego los integradores lo agrupan.

Sigamos el flujo de trabajo de Jessica mientras trabaja en sus dos funciones, colaborando en paralelo con dos desarrolladores diferentes en este entorno.
Suponiendo que ya haya clonado su repositorio, ella decide trabajar primero en `featureA`.
Ella crea una nueva sucursal para la característica y hace algo de trabajo allí:

[source,console]
-----
# Jessica's Machine
$ git checkout -b featureA
Switched to a new branch 'featureA'
$ vim lib/simplegit.rb
$ git commit -am 'add limit to log function'
[featureA 3300904] add limit to log function
 1 files changed, 1 insertions(+), 1 deletions(-)
-----

En este punto, ella necesita compartir su trabajo con John, por lo que empuja a su rama `featureA` a comprometerse con el servidor.
Jessica no tiene acceso de inserción a la rama `maestra`, solo los integradores lo hacen, por lo que debe enviar a otra sucursal para colaborar con John:

[source,console]
-----
$ git push -u origin featureA
...
To jessica@githost:simplegit.git
 * [new branch]      featureA -> featureA
-----

Jessica le envía un correo electrónico a John para decirle que ha enviado algo de trabajo a una sucursal llamada `featureA` y ahora puede verlo.
Mientras espera los comentarios de John, Jessica decide comenzar a trabajar en `featureB` con Josie.
Para comenzar, inicia una nueva rama de características, basándose en la rama `master` del servidor:

[source,console]
-----
# Jessica's Machine
$ git fetch origin
$ git checkout -b featureB origin/master
Switched to a new branch 'featureB'
-----

Ahora, Jessica hace un par de commits en la rama `featureB`:

[source,console]
-----
$ vim lib/simplegit.rb
$ git commit -am 'made the ls-tree function recursive'
[featureB e5b0fdc] made the ls-tree function recursive
 1 files changed, 1 insertions(+), 1 deletions(-)
$ vim lib/simplegit.rb
$ git commit -am 'add ls-files'
[featureB 8512791] add ls-files
 1 files changed, 5 insertions(+), 0 deletions(-)
-----

El repositorio de Jessica se ve así:

.Jessica's initial commit history.
image::images/managed-team-1.png[Jessica's initial commit history.]

Está lista para impulsar su trabajo, pero recibe un correo electrónico de Josie que indica que una rama con algunos trabajos iniciales ya fue enviada al servidor como `featureBee`.
Jessica primero necesita fusionar esos cambios con los suyos antes de poder presionar al servidor.
Luego puede buscar los cambios de Josie con `git fetch`:

[source,console]
-----
$ git fetch origin
...
From jessica@githost:simplegit
 * [new branch]      featureBee -> origin/featureBee
-----

Jessica can now merge this into the work she did with `git merge`:

[source,console]
-----
$ git merge origin/featureBee
Auto-merging lib/simplegit.rb
Merge made by recursive.
 lib/simplegit.rb |    4 ++++
 1 files changed, 4 insertions(+), 0 deletions(-)
-----

There is a bit of a problem – she needs to push the merged work in her `featureB` branch to the `featureBee` branch on the server.
She can do so by specifying the local branch followed by a colon (:) followed by the remote branch to the `git push` command:

[source,console]
-----
$ git push -u origin featureB:featureBee
...
To jessica@githost:simplegit.git
   fba9af8..cd685d1  featureB -> featureBee
-----

This is called a _refspec_.
See <<_refspec>> for a more detailed discussion of Git refspecs and different things you can do with them.
Also notice the `-u` flag; this is short for `--set-upstream`, which configures the branches for easier pushing and pulling later.

Next, John e-mails Jessica to say he's pushed some changes to the `featureA` branch and asks her to verify them.
She runs a `git fetch` to pull down those changes:

[source,console]
-----
$ git fetch origin
...
From jessica@githost:simplegit
   3300904..aad881d  featureA   -> origin/featureA
-----

Then, she can see what has been changed with `git log`:

[source,console]
-----
$ git log featureA..origin/featureA
commit aad881d154acdaeb2b6b18ea0e827ed8a6d671e6
Author: John Smith <jsmith@example.com>
Date:   Fri May 29 19:57:33 2009 -0700

    changed log output to 30 from 25
-----

Finally, she merges John's work into her own `featureA` branch:

[source,console]
-----
$ git checkout featureA
Switched to branch 'featureA'
$ git merge origin/featureA
Updating 3300904..aad881d
Fast forward
 lib/simplegit.rb |   10 +++++++++-
1 files changed, 9 insertions(+), 1 deletions(-)
-----

Jessica wants to tweak something, so she commits again and then pushes this back up to the server:

[source,console]
-----
$ git commit -am 'small tweak'
[featureA 774b3ed] small tweak
 1 files changed, 1 insertions(+), 1 deletions(-)
$ git push
...
To jessica@githost:simplegit.git
   3300904..774b3ed  featureA -> featureA
-----

Jessica's commit history now looks something like this:

.Jessica's history after committing on a feature branch.
image::images/managed-team-2.png[Jessica's history after committing on a feature branch.]

Jessica, Josie, and John inform the integrators that the `featureA` and `featureBee` branches on the server are ready for integration into the mainline.
After the integrators merge these branches into the mainline, a fetch will bring down the new merge commit, making the history look like this:

.Jessica's history after merging both her topic branches.
image::images/managed-team-3.png[Jessica's history after merging both her topic branches.]

Many groups switch to Git because of this ability to have multiple teams working in parallel, merging the different lines of work late in the process.
The ability of smaller subgroups of a team to collaborate via remote branches without necessarily having to involve or impede the entire team is a huge benefit of Git.
The sequence for the workflow you saw here is something like this:

.Basic sequence of this managed-team workflow.
image::images/managed-team-flow.png[Basic sequence of this managed-team workflow.]

[[_public_project]]
==== Forked Public Project

(((contributing, public small project)))
Contributing to public projects is a bit different.
Because you don't have the permissions to directly update branches on the project, you have to get the work to the maintainers some other way.
This first example describes contributing via forking on Git hosts that support easy forking.
Many hosting sites support this (including GitHub, BitBucket, Google Code, repo.or.cz, and others), and many project maintainers expect this style of contribution.
The next section deals with projects that prefer to accept contributed patches via e-mail.

First, you'll probably want to clone the main repository, create a topic branch for the patch or patch series you're planning to contribute, and do your work there.
The sequence looks basically like this:

[source,console]
-----
$ git clone (url)
$ cd project
$ git checkout -b featureA
# (work)
$ git commit
# (work)
$ git commit
-----

[NOTE]
====
You may want to use `rebase -i` to squash your work down to a single commit, or rearrange the work in the commits to make the patch easier for the maintainer to review – see <<_rewriting_history>> for more information about interactive rebasing.
====

When your branch work is finished and you're ready to contribute it back to the maintainers, go to the original project page and click the ``Fork'' button, creating your own writable fork of the project.
You then need to add in this new repository URL as a second remote, in this case named `myfork`:

[source,console]
-----
$ git remote add myfork (url)
-----

Then you need to push your work up to it.
It's easiest to push the topic branch you're working on up to your repository, rather than merging into your master branch and pushing that up.
The reason is that if the work isn't accepted or is cherry picked, you don't have to rewind your master branch.
If the maintainers merge, rebase, or cherry-pick your work, you'll eventually get it back via pulling from their repository anyhow:

[source,console]
-----
$ git push -u myfork featureA
-----

(((git commands, request-pull)))
When your work has been pushed up to your fork, you need to notify the maintainer.
This is often called a pull request, and you can either generate it via the website – GitHub has its own Pull Request mechanism that we'll go over in <<_github>> – or you can run the `git request-pull` command and e-mail the output to the project maintainer manually.

The `request-pull` command takes the base branch into which you want your topic branch pulled and the Git repository URL you want them to pull from, and outputs a summary of all the changes you're asking to be pulled in.
For instance, if Jessica wants to send John a pull request, and she's done two commits on the topic branch she just pushed up, she can run this:

[source,console]
-----
$ git request-pull origin/master myfork
The following changes since commit 1edee6b1d61823a2de3b09c160d7080b8d1b3a40:
  John Smith (1):
        added a new function

are available in the git repository at:

  git://githost/simplegit.git featureA

Jessica Smith (2):
      add limit to log function
      change log output to 30 from 25

 lib/simplegit.rb |   10 +++++++++-
 1 files changed, 9 insertions(+), 1 deletions(-)
-----

The output can be sent to the maintainer–it tells them where the work was branched from, summarizes the commits, and tells where to pull this work from.

On a project for which you're not the maintainer, it's generally easier to have a branch like `master` always track `origin/master` and to do your work in topic branches that you can easily discard if they're rejected.
Having work themes isolated into topic branches also makes it easier for you to rebase your work if the tip of the main repository has moved in the meantime and your commits no longer apply cleanly.
For example, if you want to submit a second topic of work to the project, don't continue working on the topic branch you just pushed up – start over from the main repository's `master` branch:

[source,console]
-----
$ git checkout -b featureB origin/master
# (work)
$ git commit
$ git push myfork featureB
# (email maintainer)
$ git fetch origin
-----

Now, each of your topics is contained within a silo – similar to a patch queue – that you can rewrite, rebase, and modify without the topics interfering or interdepending on each other, like so:

.Initial commit history with `featureB` work.
image::images/public-small-1.png[Initial commit history with `featureB` work.]

Let's say the project maintainer has pulled in a bunch of other patches and tried your first branch, but it no longer cleanly merges.
In this case, you can try to rebase that branch on top of `origin/master`, resolve the conflicts for the maintainer, and then resubmit your changes:

[source,console]
-----
$ git checkout featureA
$ git rebase origin/master
$ git push -f myfork featureA
-----

This rewrites your history to now look like <<psp_b>>.

[[psp_b]]
.Commit history after `featureA` work.
image::images/public-small-2.png[Commit history after `featureA` work.]

Because you rebased the branch, you have to specify the `-f` to your push command in order to be able to replace the `featureA` branch on the server with a commit that isn't a descendant of it.
An alternative would be to push this new work to a different branch on the server (perhaps called `featureAv2`).

Let's look at one more possible scenario: the maintainer has looked at work in your second branch and likes the concept but would like you to change an implementation detail.
You'll also take this opportunity to move the work to be based off the project's current `master` branch.
You start a new branch based off the current `origin/master` branch, squash the `featureB` changes there, resolve any conflicts, make the implementation change, and then push that up as a new branch:

(((git commands, merge, squash)))
[source,console]
-----
$ git checkout -b featureBv2 origin/master
$ git merge --no-commit --squash featureB
# (change implementation)
$ git commit
$ git push myfork featureBv2
-----

The `--squash` option takes all the work on the merged branch and squashes it into one non-merge commit on top of the branch you're on.
The `--no-commit` option tells Git not to automatically record a commit.
This allows you to introduce all the changes from another branch and then make more changes before recording the new commit.

Now you can send the maintainer a message that you've made the requested changes and they can find those changes in your `featureBv2` branch.

.Commit history after `featureBv2` work.
image::images/public-small-3.png[Commit history after `featureBv2` work.]

[[_project_over_email]]
==== Public Project over E-Mail

(((contributing, public large project)))
Many projects have established procedures for accepting patches – you'll need to check the specific rules for each project, because they will differ.
Since there are several older, larger projects which accept patches via a developer mailing list, we'll go over an example of that now.

The workflow is similar to the previous use case – you create topic branches for each patch series you work on.
The difference is how you submit them to the project.
Instead of forking the project and pushing to your own writable version, you generate e-mail versions of each commit series and e-mail them to the developer mailing list:

[source,console]
-----
$ git checkout -b topicA
# (work)
$ git commit
# (work)
$ git commit
-----

(((git commands, format-patch)))
Now you have two commits that you want to send to the mailing list.
You use `git format-patch` to generate the mbox-formatted files that you can e-mail to the list – it turns each commit into an e-mail message with the first line of the commit message as the subject and the rest of the message plus the patch that the commit introduces as the body.
The nice thing about this is that applying a patch from an e-mail generated with `format-patch` preserves all the commit information properly.

[source,console]
-----
$ git format-patch -M origin/master
0001-add-limit-to-log-function.patch
0002-changed-log-output-to-30-from-25.patch
-----

The `format-patch` command prints out the names of the patch files it creates.
The `-M` switch tells Git to look for renames.
The files end up looking like this:

[source,console]
-----
$ cat 0001-add-limit-to-log-function.patch
From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001
From: Jessica Smith <jessica@example.com>
Date: Sun, 6 Apr 2008 10:17:23 -0700
Subject: [PATCH 1/2] add limit to log function

Limit log functionality to the first 20

---
 lib/simplegit.rb |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index 76f47bc..f9815f1 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -14,7 +14,7 @@ class SimpleGit
   end

   def log(treeish = 'master')
-    command("git log #{treeish}")
+    command("git log -n 20 #{treeish}")
   end

   def ls_tree(treeish = 'master')
--
2.1.0
-----

You can also edit these patch files to add more information for the e-mail list that you don't want to show up in the commit message.
If you add text between the `---` line and the beginning of the patch (the `diff --git` line), then developers can read it; but applying the patch excludes it.

To e-mail this to a mailing list, you can either paste the file into your e-mail program or send it via a command-line program.
Pasting the text often causes formatting issues, especially with ``smarter'' clients that don't preserve newlines and other whitespace appropriately.
Luckily, Git provides a tool to help you send properly formatted patches via IMAP, which may be easier for you.
We'll demonstrate how to send a patch via Gmail, which happens to be the e-mail agent we know best; you can read detailed instructions for a number of mail programs at the end of the aforementioned `Documentation/SubmittingPatches` file in the Git source code.

(((git commands, config)))(((email)))
First, you need to set up the imap section in your `~/.gitconfig` file.
You can set each value separately with a series of `git config` commands, or you can add them manually, but in the end your config file should look something like this:

[source,ini]
-----
[imap]
  folder = "[Gmail]/Drafts"
  host = imaps://imap.gmail.com
  user = user@gmail.com
  pass = p4ssw0rd
  port = 993
  sslverify = false
-----

If your IMAP server doesn't use SSL, the last two lines probably aren't necessary, and the host value will be `imap://` instead of `imaps://`.
When that is set up, you can use `git send-email` to place the patch series in the Drafts folder of the specified IMAP server:

[source,console]
-----
$ git send-email *.patch
0001-added-limit-to-log-function.patch
0002-changed-log-output-to-30-from-25.patch
Who should the emails appear to be from? [Jessica Smith <jessica@example.com>]
Emails will be sent from: Jessica Smith <jessica@example.com>
Who should the emails be sent to? jessica@example.com
Message-ID to be used as In-Reply-To for the first email? y
-----

Then, Git spits out a bunch of log information looking something like this for each patch you're sending:

[source,text]
-----
(mbox) Adding cc: Jessica Smith <jessica@example.com> from
  \line 'From: Jessica Smith <jessica@example.com>'
OK. Log says:
Sendmail: /usr/sbin/sendmail -i jessica@example.com
From: Jessica Smith <jessica@example.com>
To: jessica@example.com
Subject: [PATCH 1/2] added limit to log function
Date: Sat, 30 May 2009 13:29:15 -0700
Message-Id: <1243715356-61726-1-git-send-email-jessica@example.com>
X-Mailer: git-send-email 1.6.2.rc1.20.g8c5b.dirty
In-Reply-To: <y>
References: <y>

Result: OK
-----

At this point, you should be able to go to your Drafts folder, change the To field to the mailing list you're sending the patch to, possibly CC the maintainer or person responsible for that section, and send it off.

==== Summary

This section has covered a number of common workflows for dealing with several very different types of Git projects you're likely to encounter, and introduced a couple of new tools to help you manage this process.
Next, you'll see how to work the other side of the coin: maintaining a Git project.
You'll learn how to be a benevolent dictator or integration manager.
