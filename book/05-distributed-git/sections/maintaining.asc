=== Manteniendo un proyecto

(((maintaining a project)))
Además de saber cómo contribuir de manera efectiva a un proyecto, probablemente necesitarás saber cómo mantenerlo.
Esto puede comprender desde aceptar y aplicar parches generados vía `format-patch` y enviados por e-mail, hasta integrar cambios en ramas remotas para repositorios que has añadido como remotos a tu proyecto.
Tanto si mantienes un repositorio canónico como si quieres ayudar verificando o aprobando parches, necesitas conocer cómo aceptar trabajo de otros colaboradores de la forma lo más clara y sostenible posible a largo plazo.

==== Trabajando en ramas puntuales

(((branches, topic)))
Cuando estás pensando en integrar nuevo trabajo, generalmente es una buena idea probarlo en una rama puntual (topic branch) - una rama temporal específicamente creada para probar ese nuevo trabajo.
De esta forma, es fácil ajustar un parche individualmente y abandonarlo si no funciona hasta que tengas tiempo de retomarlo.
Si creas una rama simple con un nombre relacionado con el trabajo que vas a probar, como `ruby_client` o algo igualmente descriptivo, puedes recordarlo fácilmente si tienes que abandonarlo y retomarlo posteriormente.
El responsable del mantenimiento del proyecto Git también tiende a usar una nomenclatura con estas ramas – como `sc/ruby_client`, donde `sc` es la abreviatura de la persona que envió el trabajo.
Como recordarás, puedes crear la rama a partir de la rama master de la siguiente forma:

[source,console]
-----
$ git branch sc/ruby_client master
-----

O, si quieres cambiar inmediatamente a la rama, puedes usar la opción `checkout -b`:

[source,console]
-----
$ git checkout -b sc/ruby_client master
-----

Ahora estás listo para añadir el trabajo recibido en esta rama puntual y decidir si quieres incorporarlo en tus ramas a largo plazo.

[[_patches_from_email]]
==== Aplicando parches recibidos por e-mail

(((email, applying patches from)))
Si recibes por e-mail un parche que necesitas integrar en tu proyecto, deberías aplicarlo en tu rama puntual para evaluarlo.
Hay dos formas de aplicar un parche enviado por e-mail: con `git apply` o `git am`.

===== Aplicando un parche con apply

(((git commands, apply)))
Si recibiste el parche de alguien que lo generó con `git diff` o con el comando Unix `diff` (lo cual no se recomienda; consulta la siguiente sección), puedes aplicarlo con el comando `git apply`.
Suponiendo que guardaste el parche en `/tmp/patch-ruby-client.patch`, puedes aplicar lo de esta forma:

[source,console]
-----
$ git apply /tmp/patch-ruby-client.patch
-----

Esto modifica los ficheros en tu directorio de trabajo.
Es casi idéntico a ejecutar un comando `patch -p1` para aplicar el parche, aunque es más paranoico y acepta menos coincidencias aproximadas que patch.
También puede manejar ficheros nuevos, borrados y renombrados si están descritos en formato `git diff`, mientras que which `patch` no puede hacerlo.
Por último, `git apply` sigue un modelo ``aplica todo o aborta todo'', donde se aplica todo o nada, mientras que `patch` puede aplicar parches parcialemente, dejando tu directorio de trabajo en un estado inconsistente.
`git apply` es en general mucho más conservador `patch`.
No creará un commit por ti – tras ejecutarlo, debes preparar (stage) y confirmar (commit) manualmente los cambios introducidos.

También puedes usar `git apply` para comprobar si un parche se aplica de forma limpia antes de aplicarlo realmente – puedes ejecutar `git apply --check` indicando el parche:

[source,console]
-----
$ git apply --check 0001-seeing-if-this-helps-the-gem.patch
error: patch failed: ticgit.gemspec:1
error: ticgit.gemspec: patch does not apply
-----

Si no obtienes salida, entonces el parche debería aplicarse limpiamente.
Este comando también sale con un estado distinto de cero si la comprobación falla, por lo que puedes usarlo en scripts.

[[_git_am]]
===== Aplicando un parche con `am`

(((git commands, am)))
Si el colaborador es usuario de Git y conoce lo suficiente como para usar el comando `format-patch` para generar el parche, entonces tu trabajo es más sencillo, ya que el parche ya contiene información del autor y un mensaje de commit.
Si puedes, anima a tus colaboradores a usar `format-patch` en lugar de `diff` para generar parches.
Sólo deberías usar `git apply` para parches antiguos y cosas similares.

Para aplicar un parche generado con `format-patch`, usa `git am`.
Técnicamente, `git am` se construyó para leer de un fichero mbox (buzón de correo). Es un formato de texto plano simple para almacenar uno o más mensajes de correo en un fichero de texto.
Es algo parecido a esto:

[source,console]
-----
From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001
From: Jessica Smith <jessica@example.com>
Date: Sun, 6 Apr 2008 10:17:23 -0700
Subject: [PATCH 1/2] add limit to log function

Limit log functionality to the first 20
-----

Esto es el comienzo de la salida del comando `format-patch` que viste en la sección anterior.
También es un formato mbox válido.
Si alguien te ha enviado el parche por e-mail usando `git send-email` y lo has descargado en formato mbox, entonces puedes pasar ese fichero a `git am` y comenzará a aplicar todos los parches que encuentre.
Si usas un cliente de correo que puede guardar varios e-mails en formato mbox, podrías guardar conjuntos completos de parches en un único fichero y a continuación usar `git am` para aplicarlos de uno en uno.

Sin embargo, si alguien subió a un sistema de gestión de incidencias o algo parecido un parche generado con `format-patch`, podrías guardar localmente el fichero y posteriormente pasarlo a `git am` para aplicarlo:

[source,console]
-----
$ git am 0001-limit-log-function.patch
Applying: add limit to log function
-----

Puedes ver que aplicó el parche limpiamente y creó automáticamente un nuevo commit.
La información del autor se toma de las cabeceras `From` y `Date` del e-mail, y el mensaje del commit sale del `Subject` y el cuerpo del e-mail (antes del parche).
Por ejemplo, si se aplicó este parche desde el fichero mbox del ejemplo anterior, el commit generado sería algo como esto:

-----
$ git log --pretty=fuller -1
commit 6c5e70b984a60b3cecd395edd5b48a7575bf58e0
Author:     Jessica Smith <jessica@example.com>
AuthorDate: Sun Apr 6 10:17:23 2008 -0700
Commit:     Scott Chacon <schacon@gmail.com>
CommitDate: Thu Apr 9 09:19:06 2009 -0700

   add limit to log function

   Limit log functionality to the first 20
-----

El campo `Commit` indica la persona que aplicó el parche y cuándo lo aplicó.
El campo `Author` es la persona que creó originalmente el parche y cuándo fue creado.

Pero es posible que el parche no se aplique limpiamente.
Quizás tu rama principal es muy diferente de la rama a partir de la cual se creó el parche, o el parche depende de otro parche que aún no has aplicado.
En ese caso, el proceso `git am` fallará y te preguntará qué hacer:

[source,console]
-----
$ git am 0001-seeing-if-this-helps-the-gem.patch
Applying: seeing if this helps the gem
error: patch failed: ticgit.gemspec:1
error: ticgit.gemspec: patch does not apply
Patch failed at 0001.
When you have resolved this problem run "git am --resolved".
If you would prefer to skip this patch, instead run "git am --skip".
To restore the original branch and stop patching run "git am --abort".
-----

Este comando marca los conflictos en cualquier fichero para el cual detecte problemas, como si fuera una operación `merge` o `rebase`.
Estos problemas se solucionan de la misma forma - edita el fichero para resolver el conflicto, prepara (stage) el nuevo fichero, y por último ejecuta `git am --resolved` para continuar con el siguiente parche:

[source,console]
-----
$ (fix the file)
$ git add ticgit.gemspec
$ git am --resolved
Applying: seeing if this helps the gem
-----

Si quieres que Git intente resolver el conflicto de forma un poco más inteligente, puedes indicar la opción `-3` para que Git intente hacer un merge a tres bandas.
Esta opción no está activa por defecto, ya que no funciona si el commit en que el parche está basado no está en tu repositorio.
Si tienes ese commit – si el parche partió de un commit público – entonces la opción `-3` es normalmente mucho más inteligente a la hora de aplicar un parche conflictivo:

[source,console]
-----
$ git am -3 0001-seeing-if-this-helps-the-gem.patch
Applying: seeing if this helps the gem
error: patch failed: ticgit.gemspec:1
error: ticgit.gemspec: patch does not apply
Using index info to reconstruct a base tree...
Falling back to patching base and 3-way merge...
No changes -- Patch already applied.
-----

En este caso, el parche ya ha sido aplicado.
Sin la opción `-3`, parecería un conflicto.

Si estás aplicando varios parches a partir de un fichero mbox, también puedes ejecutar el comando `am` en modo interactivo, el cual se detiene en cada parche para preguntar si quieres aplicarlo:

[source,console]
-----
$ git am -3 -i mbox
Commit Body is:
--------------------------
seeing if this helps the gem
--------------------------
Apply? [y]es/[n]o/[e]dit/[v]iew patch/[a]ccept all
-----

Esto está bien si tienes guardados varios parches, ya que puedes revisar el parche previamente y no aplicarlo si ya lo has hecho.

Una vez aplicados y confirmados todos los parches ed tu rama puntual, puedes decidir cómo y cuándo integrarlos en una rama de largo recorrido.

[[_checking_out_remotes]]
==== Recuperando ramas remotas

(((branches, remote)))
Si recibes una contribución de un usuario de Git que configuró su propio repositorio, realizó cambios en él, y envió la URL del repositorio junto con el nombre de la rama remota donde están los cambios, puedes añadirlo como una rama remota y hacer integraciones (merges) de forma local.

Por ejemplo, si Jessica te envía un e-mail diciendo que tiene una nueva funcionalidad muy interesante en la rama `ruby-client` de su repositorio, puedes probarla añadiendo el repositorio remoto y recuperando localmente dicha rama:

[source,console]
-----
$ git remote add jessica git://github.com/jessica/myproject.git
$ git fetch jessica
$ git checkout -b rubyclient jessica/ruby-client
-----

Si más tarde te envía otro email con una nueva funcionalidad en otra rama, puedes recuperarla (fetch y check out) directamente porque ya tienes el repositorio remoto configurado.

Esto es más útil cuando trabajas regularmente con una persona.
Sin embargo, si alguien sólo envía un parche de forma puntual, aceptarlo vía email podría llevar menos tiempo que obligar a todo el mundo a ejecutar su propio servidor y tener que añadir y eliminar repositorios remotos continuamente para obtener unos cuantos parches.
Además, probablemente no quieras tener cientos de repositorios remotos, uno por cada persona que envía uno o dos parches.
En cualquier caso, los scripts y los servicios alojados pueden facilitar todo esto — depende en gran medida de cómo desarrollan tanto tus colaboradores como tú mismo —

Otra ventaja de esta opción es que además puedes obtener un histórico de commits.
Aunque pueden surgir los problemas habituales durante la integración (merge), al menos sabes en qué punto de tu historial se basa su trabajo; Por defecto, se realiza una integración a tres bandas, en lugar de indicar un `-3` y esperar que el parche se generara a partir de un commit público al que tengas acceso.

Si no trabajas regularmente con alguien pero aún así quieres obtener sus contribuciones de esta manera, puedes pasar la URL del repositorio remoto al comando `git pull`.
Esto recupera los cambios de forma puntual (pull) sin guardar la URL como una referencia remota:

[source,console]
-----
$ git pull https://github.com/onetimeguy/project
From https://github.com/onetimeguy/project
 * branch            HEAD       -> FETCH_HEAD
Merge made by recursive.
-----

[[_what_is_introduced]]
==== Decidiendo qué introducir

(((branches, diffing)))
Ahora tienes una rama puntual con trabajo de los colaboradores.
En este punto, puedes decidir qué quieres hacer con ella.
Esta sección repasa un par de comandos para que puedas ver cómo se usan para revisar exactamente qué se va a introducir si integras los cambios en tu rama principal.

A menudo es muy útil obtener una lista de todos los commits de una rama que no están en tu rama principal.
Puedes excluir de dicha lista los commits de tu rama principal anteponiendo la opción `--not` al nombre de la rama.
El efecto de esto es el mismo que el formato `master..contrib` que usamos anteriormente.
Por ejemplo, si un colaborador te envía dos parches y creas una rama llamada `contrib` para aplicar los parches, puedes ejecutar esto:

[source,console]
-----
$ git log contrib --not master
commit 5b6235bd297351589efc4d73316f0a68d484f118
Author: Scott Chacon <schacon@gmail.com>
Date:   Fri Oct 24 09:53:59 2008 -0700

    seeing if this helps the gem

commit 7482e0d16d04bea79d0dba8988cc78df655f16a0
Author: Scott Chacon <schacon@gmail.com>
Date:   Mon Oct 22 19:38:36 2008 -0700

    updated the gemspec to hopefully work better
-----

Para ver qué cambios introduce cada commit, recuerda que puedes indicar la opción `-p` a `git log`, y  añadirá las diferencias introducidas en cada commit.

Para tener una visión completa de qué ocurriría si integraras esta rama puntual en otra rama, podrías usar un sencillo truco para obtener los resultados correctos.
Podrías pensar en ejecutar esto:

[source,console]
-----
$ git diff master
-----

Este comando te da las diferencias, pero los resultados podrían ser confusos.
Si tu rama `master` ha avanzado desde que creaste la rama puntual, entonces obtendrás resultados aparentemente extraños.
Esto ocurre porque Git compara directamente las instantáneas del último commit de la rama puntual en la que estás con la instantánea del último commit de la rama `master`.
Por ejemplo, si has añadido una línea a un fichero en la rama `master`, al hacer una comparación directa de las instantáneas parecerá que la rama puntual va a eliminar esa línea.

Si `master` es un ancestro de tu rama puntual, esto no supone un problema; pero si los dos historiales divergen, al hacer una comparación directa parecerá que estás añadiendo todos los cambios nuevos en tu rama puntual y eliminándolos de la rama `master`.

Lo que realmente necesitas ver son los cambios añadidos en tu rama puntual – el trabajo que introducirás si integras esta rama en la `master`.
Para conseguir esto, Git compara el último commit de tu rama puntual con el primer ancestro en común respecto a la rama `master`.

Técnicamente puedes hacer esto averiguando explícitamente el ancestro común y ejecutando el `diff` sobre dicho ancestro:

[source,console]
-----
$ git merge-base contrib master
36c7dba2c95e6bbb78dfa822519ecfec6e1ca649
$ git diff 36c7db
-----

Sin embargo, eso no es lo más conveniente, así que Git ofrece un atajo para hacer eso mismo: la sintaxis del triple-punto.
En el contexto del comando `diff`, puedes poner tres puntos tras el nombre de una rama para hacer un `diff` entre el último commit de la rama en la que estás y su ancestro común con otra rama:

[source,console]
-----
$ git diff master...contrib
-----

Este comando sólo muestra el trabajo introducido en tu rama puntual actual desde su ancestro común con la rama `master`.
Es una sintaxis muy útil a recordar.

==== Integrando el trabajo de los colaboradores

(((integrating work)))
Cuando todo el trabajo de tu rama puntual está listo para ser integrado en una rama de largo recorrido, la cuestión es cómo hacerlo.
Es más, ¿qué flujo de trabajo general quieres seguir para mantener el proyecto?
Tienes varias opciones, y vamos a ver algunas de ellas.

===== Integrando flujos de trabajo

(((workflows, merging)))
Un flujo de trabajo sencillo integra tu trabajo en tu rama `master`.
En este escenario, tienes una rama `master` que contiene básicamente código estable.
Cuando tienes trabajo propio en una rama puntual o trabajo aportado por algún colaborador que ya has verificado, lo integras en tu rama `master`, borras la rama puntual, y continúas el proceso.
Si tenemos un repositorio con trabajo en dos ramas llamadas `ruby_client` y `php_client`, tal y como se muestra en <<merwf_a>> e integramos primero `ruby_client` y luego `php_client`, entonces tu historial terminará con este aspecto <<merwf_b>>.

[[merwf_a]]
.Historial con varias ramas puntuales.
image::images/merging-workflows-1.png[Historial con varias ramas puntuales.]

[[merwf_b]]
.Tras integrar una rama puntual.
image::images/merging-workflows-2.png[Tras integrar una rama puntual.]

That is probably the simplest workflow, but it can possibly be problematic if you're dealing with larger or more stable projects where you want to be really careful about what you introduce.

If you have a more important project, you might want to use a two-phase merge cycle.
In this scenario, you have two long-running branches, `master` and `develop`, in which you determine that `master` is updated only when a very stable release is cut and all new code is integrated into the `develop` branch.
You regularly push both of these branches to the public repository.
Each time you have a new topic branch to merge in (<<merwf_c>>), you merge it into `develop` (<<merwf_d>>); then, when you tag a release, you fast-forward `master` to wherever the now-stable `develop` branch is (<<merwf_e>>).

[[merwf_c]]
.Before a topic branch merge.
image::images/merging-workflows-3.png[Before a topic branch merge.]

[[merwf_d]]
.After a topic branch merge.
image::images/merging-workflows-4.png[After a topic branch merge.]

[[merwf_e]]
.After a project release.
image::images/merging-workflows-5.png[After a topic branch release.]

This way, when people clone your project's repository, they can either check out master to build the latest stable version and keep up to date on that easily, or they can check out develop, which is the more cutting-edge stuff.
You can also continue this concept, having an integrate branch where all the work is merged together.
Then, when the codebase on that branch is stable and passes tests, you merge it into a develop branch; and when that has proven itself stable for a while, you fast-forward your master branch.

===== Large-Merging Workflows

(((workflows, "merging (large)")))
The Git project has four long-running branches: `master`, `next`, and `pu` (proposed updates) for new work, and `maint` for maintenance backports.
When new work is introduced by contributors, it's collected into topic branches in the maintainer's repository in a manner similar to what we've described (see <<merwf_f>>).
At this point, the topics are evaluated to determine whether they're safe and ready for consumption or whether they need more work.
If they're safe, they're merged into `next`, and that branch is pushed up so everyone can try the topics integrated together.

[[merwf_f]]
.Managing a complex series of parallel contributed topic branches.
image::images/large-merges-1.png[Managing a complex series of parallel contributed topic branches.]

If the topics still need work, they're merged into `pu` instead.
When it's determined that they're totally stable, the topics are re-merged into `master` and are then rebuilt from the topics that were in `next` but didn't yet graduate to `master`.
This means `master` almost always moves forward, `next` is rebased occasionally, and `pu` is rebased even more often:

.Merging contributed topic branches into long-term integration branches.
image::images/large-merges-2.png[Merging contributed topic branches into long-term integration branches.]

When a topic branch has finally been merged into `master`, it's removed from the repository.
The Git project also has a `maint` branch that is forked off from the last release to provide backported patches in case a maintenance release is required.
Thus, when you clone the Git repository, you have four branches that you can check out to evaluate the project in different stages of development, depending on how cutting edge you want to be or how you want to contribute; and the maintainer has a structured workflow to help them vet new contributions.

[[_rebase_cherry_pick]]
===== Rebasing and Cherry Picking Workflows

(((workflows, rebasing and cherry-picking)))
Other maintainers prefer to rebase or cherry-pick contributed work on top of their master branch, rather than merging it in, to keep a mostly linear history.
When you have work in a topic branch and have determined that you want to integrate it, you move to that branch and run the rebase command to rebuild the changes on top of your current master (or `develop`, and so on) branch.
If that works well, you can fast-forward your `master` branch, and you'll end up with a linear project history.

(((git commands, cherry-pick)))
The other way to move introduced work from one branch to another is to cherry-pick it.
A cherry-pick in Git is like a rebase for a single commit.
It takes the patch that was introduced in a commit and tries to reapply it on the branch you're currently on.
This is useful if you have a number of commits on a topic branch and you want to integrate only one of them, or if you only have one commit on a topic branch and you'd prefer to cherry-pick it rather than run rebase.
For example, suppose you have a project that looks like this:

.Example history before a cherry-pick.
image::images/rebasing-1.png[Example history before a cherry-pick.]

If you want to pull commit `e43a6` into your master branch, you can run

[source,console]
-----
$ git cherry-pick e43a6fd3e94888d76779ad79fb568ed180e5fcdf
Finished one cherry-pick.
[master]: created a0a41a9: "More friendly message when locking the index fails."
 3 files changed, 17 insertions(+), 3 deletions(-)
-----

This pulls the same change introduced in `e43a6`, but you get a new commit SHA-1 value, because the date applied is different.
Now your history looks like this:

.History after cherry-picking a commit on a topic branch.
image::images/rebasing-2.png[History after cherry-picking a commit on a topic branch.]

Now you can remove your topic branch and drop the commits you didn't want to pull in.

===== Rerere

(((git commands, rerere)))(((rerere)))
If you're doing lots of merging and rebasing, or you're maintaining a long-lived topic branch, Git has a feature called ``rerere'' that can help.

Rerere stands for ``reuse recorded resolution'' – it's a way of shortcutting manual conflict resolution.
When rerere is enabled, Git will keep a set of pre- and post-images from successful merges, and if it notices that there's a conflict that looks exactly like one you've already fixed, it'll just use the fix from last time, without bothering you with it.

This feature comes in two parts: a configuration setting and a command.
The configuration setting is `rerere.enabled`, and it's handy enough to put in your global config:

[source,console]
----
$ git config --global rerere.enabled true
----

Now, whenever you do a merge that resolves conflicts, the resolution will be recorded in the cache in case you need it in the future.

If you need to, you can interact with the rerere cache using the `git rerere` command.
When it's invoked alone, Git checks its database of resolutions and tries to find a match with any current merge conflicts and resolve them (although this is done automatically if `rerere.enabled` is set to `true`).
There are also subcommands to see what will be recorded, to erase specific resolution from the cache, and to clear the entire cache. We will cover rerere in more detail in <<_rerere>>.

[[_tagging_releases]]
==== Tagging Your Releases

(((tags)))(((tags, signing)))
When you've decided to cut a release, you'll probably want to drop a tag so you can re-create that release at any point going forward.
You can create a new tag as discussed in <<_git_basics_chapter>>.
If you decide to sign the tag as the maintainer, the tagging may look something like this:

[source,console]
-----
$ git tag -s v1.5 -m 'my signed 1.5 tag'
You need a passphrase to unlock the secret key for
user: "Scott Chacon <schacon@gmail.com>"
1024-bit DSA key, ID F721C45A, created 2009-02-09
-----

If you do sign your tags, you may have the problem of distributing the public PGP key used to sign your tags.
The maintainer of the Git project has solved this issue by including their public key as a blob in the repository and then adding a tag that points directly to that content.
To do this, you can figure out which key you want by running `gpg --list-keys`:

[source,console]
-----
$ gpg --list-keys
/Users/schacon/.gnupg/pubring.gpg
---------------------------------
pub   1024D/F721C45A 2009-02-09 [expires: 2010-02-09]
uid                  Scott Chacon <schacon@gmail.com>
sub   2048g/45D02282 2009-02-09 [expires: 2010-02-09]
-----

Then, you can directly import the key into the Git database by exporting it and piping that through `git hash-object`, which writes a new blob with those contents into Git and gives you back the SHA-1 of the blob:

[source,console]
-----
$ gpg -a --export F721C45A | git hash-object -w --stdin
659ef797d181633c87ec71ac3f9ba29fe5775b92
-----

Now that you have the contents of your key in Git, you can create a tag that points directly to it by specifying the new SHA-1 value that the `hash-object` command gave you:

[source,console]
-----
$ git tag -a maintainer-pgp-pub 659ef797d181633c87ec71ac3f9ba29fe5775b92
-----

If you run `git push --tags`, the `maintainer-pgp-pub` tag will be shared with everyone.
If anyone wants to verify a tag, they can directly import your PGP key by pulling the blob directly out of the database and importing it into GPG:

[source,console]
-----
$ git show maintainer-pgp-pub | gpg --import
-----

They can use that key to verify all your signed tags.
Also, if you include instructions in the tag message, running `git show <tag>` will let you give the end user more specific instructions about tag verification.

[[_build_number]]
==== Generating a Build Number

(((build numbers)))(((git commands, describe)))
Because Git doesn't have monotonically increasing numbers like 'v123' or the equivalent to go with each commit, if you want to have a human-readable name to go with a commit, you can run `git describe` on that commit.
Git gives you the name of the nearest tag with the number of commits on top of that tag and a partial SHA-1 value of the commit you're describing:

[source,console]
-----
$ git describe master
v1.6.2-rc1-20-g8c5b85c
-----

This way, you can export a snapshot or build and name it something understandable to people.
In fact, if you build Git from source code cloned from the Git repository, `git --version` gives you something that looks like this.
If you're describing a commit that you have directly tagged, it gives you the tag name.

The `git describe` command favors annotated tags (tags created with the `-a` or `-s` flag), so release tags should be created this way if you're using `git describe`, to ensure the commit is named properly when described.
You can also use this string as the target of a checkout or show command, although it relies on the abbreviated SHA-1 value at the end, so it may not be valid forever.
For instance, the Linux kernel recently jumped from 8 to 10 characters to ensure SHA-1 object uniqueness, so older `git describe` output names were invalidated.

[[_preparing_release]]
==== Preparing a Release

(((releasing)))(((git commands, archive)))
Now you want to release a build.
One of the things you'll want to do is create an archive of the latest snapshot of your code for those poor souls who don't use Git.
The command to do this is `git archive`:

[source,console]
-----
$ git archive master --prefix='project/' | gzip > `git describe master`.tar.gz
$ ls *.tar.gz
v1.6.2-rc1-20-g8c5b85c.tar.gz
-----

If someone opens that tarball, they get the latest snapshot of your project under a project directory.
You can also create a zip archive in much the same way, but by passing the `--format=zip` option to `git archive`:

[source,console]
-----
$ git archive master --prefix='project/' --format=zip > `git describe master`.zip
-----

You now have a nice tarball and a zip archive of your project release that you can upload to your website or e-mail to people.

[[_the_shortlog]]
==== The Shortlog

(((git commands, shortlog)))
It's time to e-mail your mailing list of people who want to know what's happening in your project.
A nice way of quickly getting a sort of changelog of what has been added to your project since your last release or e-mail is to use the `git shortlog` command.
It summarizes all the commits in the range you give it; for example, the following gives you a summary of all the commits since your last release, if your last release was named v1.0.1:

[source,console]
-----
$ git shortlog --no-merges master --not v1.0.1
Chris Wanstrath (8):
      Add support for annotated tags to Grit::Tag
      Add packed-refs annotated tag support.
      Add Grit::Commit#to_patch
      Update version and History.txt
      Remove stray `puts`
      Make ls_tree ignore nils

Tom Preston-Werner (4):
      fix dates in history
      dynamic version method
      Version bump to 1.0.2
      Regenerated gemspec for version 1.0.2
-----

You get a clean summary of all the commits since v1.0.1, grouped by author, that you can e-mail to your list.