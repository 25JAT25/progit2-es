=== Scripting en GitHub

Ya conocemos casi todas las características y workflows de GitHub. Sin
embargo, cualquier grupo o proyecto medianamente grande necesitará
personalizar o integrar GitHub con servicios externos.

Por suerte para nosotros, GitHub es bastante 'hackeable' en muchos
sentidos. En esta sección veremos cómo se usan los 'enganches'
(hooks) de GitHub y las API para conseguir hacer lo que queremos.

==== Enganches

Las secciones Hooks y Services de la página de administración del
repositorio en Github es la forma más simple de hacer que GitHub
interactúe con sistemas externos.

===== Servicios

En primer lugar, echaremos un ojo a los Servicios. Ambos, enganches
y servicios pueden configurarse desde la sección Settings del
repositorio, el mismo sitio donde vimos que podíamos añadir
colaboradores al proyecto o cambiar la rama predeterminada.
Bajo la opción ``Webhooks and Services'' veremos algo similar
a <<_services_hooks>>.

[[_services_hooks]]
.Sección Services and Hooks.
image::images/scripting-01-services.png[Servicios y enganches]

Hay docenas de servicios que podemos elegir, muchos de ellos
para integrarse en otros sistemas de código abierto o 
comerciales. Muchos son servicios de integración continua,
gestores de incidencias y fallos, salas de charla y sistemas
de documentación. Veremos cómo levantar un servicio sencillo,
el enganche con el correo electrónico. Si elegimos ``email''
en la opción ``Add Service'' veremos una pantalla de
configuración similar a <<_service_config>>.

[[_service_config]]
.Configuración de servicio de correo.
image::images/scripting-02-email-service.png[Servicio de correo]

En este caso, si pulsamos en el botón ``Add service'', la
dirección de correo especificada recibirá un correo cada vez que
alguien envía cambios (push) al repositorio. Los servicios pueden
dispararse con muchos otros tipos de eventos, aunque la mayoría
solo se usan para los eventos de envío de cambios (push) y hacer
algo con los datos del mismo.

Si quieres integrar algún sistema concreto con GitHub, debes
mirar si hay algún servicio de integración ya creado. Por ejemplo,
si usas Jenkins para ejecutar pruebas de tu código, puedes activar
el servicio de integración de Jenkins que lo disparará cada vez
que alguien altera el repositorio.

===== Hooks (enganches)

Si necesitas algo más concreto o quieres integrarlo con un servicio
o sitio no incluido en la lista, puedes usar el sistema de enganches
más genérico. Los enganches de GitHub son bastante simples. Indicas
una URL y GitHub enviará una petición HTTP a dicha URL cada vez que
suceda el evento que quieras.

Normalmente, esto funcionará si puedes configurar un pequeño servicio
web para escuchar las peticiones de GitHub y luego hacer algo con los
datos que son enviados.

Para activar un enganche, pulsa en el botón ``Add webhook'' de
<<_services_hooks>>. Esto mostrará una página como <<_web_hook>>.

[[_web_hook]]
.Configuración de enganches web.
image::images/scripting-03-webhook.png[Enganches web]

La configuración de un enganche web es bastante simple. Casi siempre
basta con incluir una URL y una clave secreta, y pulsar en ``Add webhook''.
Hay algunas opciones sobre qué eventos quieres que disparen el envío de
datos (de forma predeterminada el único evento considerado es el evento
`push`, de cuando alguien sube algo a cualquier rama del repositorio).

Veamos un pequeño ejemplo de servicio web para manejar un enganche web.
Usaremos el entorno Sinatra de Ruby puesto que es conciso y podrás
entender con facilidad qué estamos haciendo.

Pongamos que queremos recibir un correo cada vez que alguien sube algo
a una rama concreta del repositorio, modificando un fichero en particular.
Podríamos hacerlo con un código similar a este:

[source,ruby]
----
require 'sinatra'
require 'json'
require 'mail'

post '/payload' do
  push = JSON.parse(request.body.read) # parse the JSON

  # gather the data we're looking for
  pusher = push["pusher"]["name"]
  branch = push["ref"]

  # get a list of all the files touched
  files = push["commits"].map do |commit|
    commit['added'] + commit['modified'] + commit['removed']
  end
  files = files.flatten.uniq

  # check for our criteria
  if pusher == 'schacon' &&
     branch == 'ref/heads/special-branch' &&
     files.include?('special-file.txt')

    Mail.deliver do
      from     'tchacon@example.com'
      to       'tchacon@example.com'
      subject  'Scott Changed the File'
      body     "ALARM"
    end
  end
end
----

Aquí estamos tomando el bloque JSON que GitHub entrega y mirando
quién hizo el envío, qué rama se envió y qué ficheros se modificaron en cada
commit realizado en este push. Entonces, comprobamos si se cumple nuestro
criterio y enviamos un correo si es así.

Para poder probar algo como esto, tienes una consola de desarrollador en la
misma pantalla donde configuraste el enganche, donde se puede ver las últimas
veces que GitHub ha intentado ejecutar el enganche. Para cada uno, puedes
mirar qué información se ha enviado, y si fue recibido correctamente, junto
con las cabeceras correspondientes de la petición y de la respuesta. Esto
facilita mucho las pruebas de tus enganches.

[[_web_hook_debug]]
.Depuración de un web hook.
image::images/scripting-04-webhook-debug.png[Depuración de Webhook]

Otra cosa muy interesante es que puedes repetir el envío de cualquier petición
para probar el servicio con facilidad.

Para más información sobre cómo escribir webhooks (enganches) y los
diferentes tipos de eventos que puedes tratar, puedes ir a la
documentación del desarrollador de GitHub, en:
https://developer.github.com/webhooks/

==== La API de GitHub

(((GitHub, API)))
Servicios y enganches nos sirven para recibir notificaciones ``push'' sobre
eventos que suceden en tus repositorios. Pero, ¿qué pasa si necesitas más
información acerca de estos eventos? ¿y si necesitas automatizar algo como
añadir colaboradores o etiquetar incidencias?

Aquí es donde entra en juego la API de GitHub. GitHub tiene montones de
llamadas de API para hacer casi cualquier cosa que puedes hacer via web,
de forma automatizada. En esta sección aprenderemos cómo autentificar y
conectar a la API, cómo comentar una incidencia y cómo cambiar el estado
de un Pull Request mediante la API.

==== Uso Básico

Lo más basico que podemos hacer es una petición GET a una llamada que no
necesite autentificación. Por ejemplo, información solo lectura de un
proyecto de código abierto. Por ejemplo, si queremos conocer información
acerca del usuario ``schacon'', podemos ejecutar algo como:

[source,javascript]
----
$ curl https://api.github.com/users/schacon
{
  "login": "schacon",
  "id": 70,
  "avatar_url": "https://avatars.githubusercontent.com/u/70",
# …
  "name": "Scott Chacon",
  "company": "GitHub",
  "following": 19,
  "created_at": "2008-01-27T17:19:28Z",
  "updated_at": "2014-06-10T02:37:23Z"
}
----

Hay muchísimas llamadas como esta para obtener información sobre
organizaciones, proyectos, incidencias, commits, es decir, todo lo que
podemos ver públicamente en la web de GitHub. Se puede usar la API para
otras cosas como ver un fichero Markdown cualquier o encontrar una
plantilla de `.gitignore`.

[source,javascript]
----
$ curl https://api.github.com/gitignore/templates/Java
{
  "name": "Java",
  "source": "*.class

# Mobile Tools for Java (J2ME)
.mtj.tmp/

# Package Files #
*.jar
*.war
*.ear

# virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xml
hs_err_pid*
"
}
----


==== Comentarios en una incidencia

Sin embargo, si lo que quieres es realizar una acción como comentar una
incidencia o un Pull Request, o si quieres ver o interactuar con un
contenido privado, necesitas identificarte.

Hay varias formas de hacerlo. Puedes usar la autentificación básica, con
tu usuario y tu contraseña, aunque generalmente es mejor usar un token de 
acceso personal. Puedes generarlo en la opción ``Applications'' de tu
página de ajustes personales.

[[_access_token]]
.Generación del token de acceso.
image::images/scripting-05-access-token.png[Token de acceso]

Te preguntará acerca del ámbito que quieres para el token y una descripción.
Asegúrate de usar una buena descripción para que te resulte fácil localizar
aquellos token que ya no necesitas.

GitHub te permitirá ver el token una vez, por lo que tienes que copiarlo en
ese momento. Ahora podrás identificarte en el script con el token, en lugar
del usuario y la contraseña. Esto está bien porque puedes limitar el ámbito de
lo que se quiere hacer y porque el token se puede anular.

También tiene la ventana de incrementar la tasa de accesos. Sin la
autentificación podrás hacer 60 peticiones a la hora. Con una identificación
el número de accesos permitidos sube a 5,000 por hora.

Realicemos entinces un comentario en una de nuestras incidencias. Por ejemplo,
queremos dejar un comentario en la incidencia #6. Para ello, hacemos una
petición HTTP POST a `repos/<usuario>/<repo>/issues/<num>/comments` con el
token que acabamos de generar como cabecera Authorization.

[source,javascript]
----
$ curl -H "Content-Type: application/json" \
       -H "Authorization: token TOKEN" \
       --data '{"body":"A new comment, :+1:"}' \
       https://api.github.com/repos/schacon/blink/issues/6/comments
{
  "id": 58322100,
  "html_url": "https://github.com/schacon/blink/issues/6#issuecomment-58322100",
  ...
  "user": {
    "login": "tonychacon",
    "id": 7874698,
    "avatar_url": "https://avatars.githubusercontent.com/u/7874698?v=2",
    "type": "User",
  },
  "created_at": "2014-10-08T07:48:19Z",
  "updated_at": "2014-10-08T07:48:19Z",
  "body": "A new comment, :+1:"
}
----

Ahora, si vas a la incidencia, verás el comentario que acabas de enviar tal como
en <<_api_comment>>.

[[_api_comment]]
.Comentario enviado desde la API de GitHub.
image::images/scripting-06-comment.png[Comentario via API]

Puedes usar la API para hacer todo lo que harías en el sitio web: crear y
ajustar hitos, asignar gente a incidencias o pull requests, crear y cambiar
etiquetas, acceder a datos de commit, crear nuevos commits y ramas, abrir, cerrar
o fusionar Pull Requests, crear y editar equipos, comentar líneas de cambio en
Pull Requests, buscar en el sitio y mucho más.

==== Changing the Status of a Pull Request

One final example we'll look at since it's really useful if you're working with Pull Requests. Each commit can have one or more statuses associated with it and there is an API to add and query that status.

Most of the Continuous Integration and testing services make use of this API to react to pushes by testing the code that was pushed, and then report back if that commit has passed all the tests. You could also use this to check if the commit message is properly formatted, if the submitter followed all your contribution guidelines, if the commit was validly signed -- any number of things.

Let's say you set up a webhook on your repository that hits a small web service that checks for a `Signed-off-by` string in the commit message.

[source,ruby]
----
require 'httparty'
require 'sinatra'
require 'json'

post '/payload' do
  push = JSON.parse(request.body.read) # parse the JSON
  repo_name = push['repository']['full_name']

  # look through each commit message
  push["commits"].each do |commit|

    # look for a Signed-off-by string
    if /Signed-off-by/.match commit['message']
      state = 'success'
      description = 'Successfully signed off!'
    else
      state = 'failure'
      description = 'No signoff found.'
    end

    # post status to GitHub
    sha = commit["id"]
    status_url = "https://api.github.com/repos/#{repo_name}/statuses/#{sha}"

    status = {
      "state"       => state,
      "description" => description,
      "target_url"  => "http://example.com/how-to-signoff",
      "context"     => "validate/signoff"
    }
    HTTParty.post(status_url,
      :body => status.to_json,
      :headers => {
        'Content-Type'  => 'application/json',
        'User-Agent'    => 'tonychacon/signoff',
        'Authorization' => "token #{ENV['TOKEN']}" }
    )
  end
end
----

Hopefully this is fairly simple to follow. In this web hook handler we look through each commit that was just pushed, we look for the string 'Signed-off-by' in the commit message and finally we POST via HTTP to the `/repos/<user>/<repo>/statuses/<commit_sha>` API endpoint with the status.

In this case you can send a state ('success', 'failure', 'error'), a description of what happened, a target URL the user can go to for more information and a ``context'' in case there are multiple statuses for a single commit. For example, a testing service may provide a status and a validation service like this may also provide a status -- the ``context'' field is how they're differentiated.

If someone opens a new Pull Request on GitHub and this hook is set up, you may see something like <<_commit_status>>.

[[_commit_status]]
.Commit status via the API.
image::images/scripting-07-status.png[Commit status]

You can now see a little green check mark next to the commit that has a ``Signed-off-by'' string in the message and a red cross through the one where the author forgot to sign off. You can also see that the Pull Request takes the status of the last commit on the branch and warns you if it is a failure. This is really useful if you're using this API for test results so you don't accidentally merge something where the last commit is failing tests.

==== Octokit

Though we've been doing nearly everything through `curl` and simple HTTP requests in these examples, several open-source libraries exist that make this API available in a more idiomatic way.
At the time of this writing, the supported languages include Go, Objective-C, Ruby, and .NET.
Check out http://github.com/octokit[] for more information on these, as they handle much of the HTTP for you.

Hopefully these tools can help you customize and modify GitHub to work better for your specific workflows.
For complete documentation on the entire API as well as guides for common tasks, check out https://developer.github.com[].
