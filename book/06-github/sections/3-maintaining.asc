[[_maintaining_gh_project]]
=== Mantenimiento de un proyecto

Ahora que ya sabes cómo ayudar a un proyecto, veamos el otro lado: cómo
puedes crear, administrar y mantener tu propio proyecto.

==== Creación de un repositorio

Vamos a crear un nuevo repositorio para compartir nuestro código en él.
Comienza pulsando el botón ``New repository'' en el lado derecho de tu
página principal, o bien desde el botón `+` en la barra de botones cercano
a tu nombre de usuario, tal como se ve en <<_new_repo_dropdown>>.

.La zona ``Your repositories''.
image::images/newrepo.png[La zona ``Your repositories''.]

[[_new_repo_dropdown]]
.Desplegable ``New repository''.
image::images/new-repo.png[Desplegable ``New repository''.]

Esto te llevará al formulario para crear un nuevo repositorio:

.Formulario para crear repositorio.
image::images/newrepoform.png[Formulario para crear repositorio.]

Todo lo que tienes que hacer aquí es darle un nombre al proyecto; el resto
de campos es totalmente opcional. Por ahora, pulsa en el botón ``Create
Repository'' y listo: se habrá creado el repositorio en GitHub, con el
nombre `<usuario>/<proyecto>`

Dado que no tiene todavía contenido, GitHub te mostrará instrucciones para
crear el repositorio Git, o para conectarlo a un proyecto Git existente.
No entraremos aquí en esto; si necesitas refrescarlo,
revisa el capítulo <<_git_basics_chapter>>.

Ahora que el proyecto está alojado en GitHub, puedes dar la URL a cualquiera
con quien quieras compartirlo. Cada proyecto en GitHub es accesible mediante
HTTP como `https://github.com/<usuario>/<proyecto>`, y también con SSH
con la dirección `git@github.com:<usuario>/<proyecto>`.
Git puede obtener y enviar cambios en ambas URL, ya que tienen control de
acceso basado en las credenciales del usuario.

[NOTE]
====
Suele ser preferible compartir la URL de tipo HTTP de los proyectos públicos,
puesto que así el usuario no necesitará una cuenta GitHub para clonar el
proyecto. Si das la dirección SSH, los usuarios necesitarán una cuenta
GitHub y subir una clave SSH para acceder. Además, la URL HTTP es exactamente
la misma que usamos para ver la página web del proyecto.
====

==== Añadir colaboradores

Si estás trabajando con otras personas y quieres darle acceso de escritura,
necesitarás añadirlas como ``colaboradores''. Si Ben, Jeff y Louise se crean
cuentas en GitHub, y quieres darles acceso de escritura a tu repositorio,
los tienes que añadir al proyecto.
Al hacerlo le darás permiso de ``push'', que significa que tendrán tanto
acceso de lectura como de escritura, en el proyecto y en el repositorio Git.

.Enlace a ajustes del repositorio.
image::images/reposettingslink.png[Enlace a ajustes del repositorio.]

Selecciona ``Collaborators'' del menú del lado izquierdo. Simplemente, teclea
el usuario en la caja, y pulsa en ``Add collaborator.''
Puedes repetir esto las veces que necesites para dar acceso a otras personas.
Si necesitas quitar un acceso, pulsa en la ``X'' del lado derecho del usuario.

.Colaboradores del repositorio.
image::images/collaborators.png[Colaboradores del repositorio.]

==== Gestión de los Pull Requests

Ahora que tienes un proyecto con algo de código, y probablemente algunos
colaboradores con acceso de escritura, veamos qué pasa cuando alguien te
hace un Pull Request.

Los Pull Requests pueden venir de una rama en una bifurcación del repositorio,
o pueden venir de una rama pero del mismo repositorio. La única diferencia
es que, en el primer, caso procede de gente que no tiene acceso de escritura
a tu proyecto y quiere integrar en el tuyo cambios interesantes, mientras que
en el segundo caso procede de gente con acceso al repositorio.

En los siguientes ejemplos, supondremos que eres ``tonychacon'' y has
creado un nuevo proyecto para Arduino llamado ``fade''.

[[_email_notifications]]
===== Notificaciones por correo electrónico

Cuando alguien realiza un cambio en el código y te crea un Pull Request,
debes recibir una notificación por correo electrónico avisándote, con un
aspecto similar a <<_email_pr>>.

[[_email_pr]]
.Notificación por correo de nuevo Pull Request.
image::images/maint-01-email.png[Notificación por correo de nuevo Pull Request]

Hay algunas cosas a destacar en este correo. En primer lugar, te dará
un pequeño diffstat (es decir, una lista de ficheros cambiados y en qué
medida). Además, trae un enlace al Pull Request y algunas URL que puedes
usar desde la línea de comandos.

Si observas la línea que dice `git pull <url> patch-1`, es una forma simple
de fusionar una rama remota sin tener que añadirla localmente. Lo vimos esto
rápidamente en <<_checking_out_remotes>>. Si lo deseas, puedes crear y
cambiar a una rama y luego ejecutar el comando para fusionar los cambios
del Pull Request.

Las otras URL interesantes son las de `.diff` y `.patch`, que como su nombre
indican, proporcionan diff unificados y formatos de parche del Pull Request.
Técnicamente, podrías fusionar con algo como:

[source,console]
----
$ curl http://github.com/tonychacon/fade/pull/1.patch | git am
----

===== Colaboración en el Pull Request

Como hemos visto en <<_github_flow>>, puedes participar en una discusión con
la persona que generó el Pull Request. Puedes comentar líneas concretas de
código, comentar commits completos o comentar el Pull Request en sí mismo,
utilizando donde quieras el formato Markdown.

Cada vez que alguien comenta, recibirás nuevas notificaciones por correo,
lo que te permite vigilar todo lo que pasa. Cada correo tendrá un enlace
a la actividad que ha tenido lugar, y además puedes responder al comentario
simplemente contestando al correo.

.Las respuestas a correos se incluyen en el hilo de discusión.
image::images/maint-03-email-resp.png[Respuesta a correo-e]

Una vez que el código está como quieres y quieres fusionarlo, puedes copiar
el código y fusionarlo localmente, mediante la sintaxis ya conocida de
`git pull <url> <branch>`, o bien añadiendo el fork como nuevo remoto,
bajándotelo y luego fusionándolo.

Si la fusión es trivial, también puedes pulsar el botón ``Merge'' en GitHub.
Esto realizará una fusión ``sin avance rápido'', creando un commit de fusión
incluso si era posible una fusión con avance rápido. Esto significa que
cada vez que pulses el botón Merge, se creará un commit de fusión. Como verás
en <<_merge_button>>, GitHub te da toda esta información si pulsas el el enlace
de ayuda.

[[_merge_button]]
.Botón Merge e instrucciones para fusionar manualmente un Pull Request.
image::images/maint-02-merge.png[Botón Merge]

Si decides que no quieres fusionar, también puedes cerrar el Pull Request
y la persona que lo creó será notificada.

[[_pr_refs]]
===== Referencias de Pull Request

Si tienes muchos Pull Request y no quieres añadir un montón de remotos o
hacer muchos cada vez, hay un pequeño truco que GitHub te permite. Es
un poco avanzado y lo veremos en detalle después en <<_refspec>>, pero puede
ser bastante útil.

En GitHub tenemos que las ramas de Pull Request son una especie de
pseudo-ramas del servidor. De forma predeterminada no las obtendrás cuando
hagas un clonado, pero hay una forma algo oscura de acceder a ellos.

Para demostrarlo, usaremos un comando de bajo nivel (conocido como de
``fontanería'', sabremos más sobre esto en <<_plumbing_porcelain>>) llamado
`ls-remote`. Este comando no se suele usar en el día a día de Git pero es
útil para ver las referencias presentes en el servidor.

Si ejecutamos este comando sobre el repositorio ``blink'' que hemos estado
usando antes, obtendremos una lista de ramas, etiquetas y otras referencias
del repositorio.

[source,console]
----
$ git ls-remote https://github.com/schacon/blink
10d539600d86723087810ec636870a504f4fee4d	HEAD
10d539600d86723087810ec636870a504f4fee4d	refs/heads/master
6a83107c62950be9453aac297bb0193fd743cd6e	refs/pull/1/head
afe83c2d1a70674c9505cc1d8b7d380d5e076ed3	refs/pull/1/merge
3c8d735ee16296c242be7a9742ebfbc2665adec1	refs/pull/2/head
15c9f4f80973a2758462ab2066b6ad9fe8dcf03d	refs/pull/2/merge
a5a7751a33b7e86c5e9bb07b26001bb17d775d1a	refs/pull/4/head
31a45fc257e8433c8d8804e3e848cf61c9d3166c	refs/pull/4/merge
----

Por supuesto, si estás en tu repositorio y tecleas `git ls-remote origin`
podrás ver algo similar pero para el remoto etiquetado como `origin`.

Si el repositorio está en GitHub y tienes Pull Requests abiertos, tendrás estas
referencias con el prefijo `refs/pull`. Básicamente, son ramas, pero ya que
no están bajo `refs/heads/`, no las obtendrás normalmente cuando clonas o
te bajas el repositorio del servidor, ya que el proceso de obtención las
ignora.

Hay dos refeerencias por cada Pull Request, la que termina en `/head` apunta
exactamente al último commit de la rama del Pull Request. Así si alguien abre
un Pull Request en el repositorio y su rama se llama `bug-fix` apuntando al
commit `a5a775`, en nuestro repositorio no tendremos una rama `bug-fix` (puesto
que está en el fork) pero tendremos el `pull/<pr#>/head` apuntando a
`a5a775`. Esto significa que podemos obtener fácilmente cada Pull Request sin
tener que añadir un montón de remotos.

Ahora puedes obtenerlo directamente.

[source,console]
----
$ git fetch origin refs/pull/958/head
From https://github.com/libgit2/libgit2
 * branch            refs/pull/958/head -> FETCH_HEAD
----

Esto dice a Git, ``Conecta al remoto `origin` y descarga la referencia
llamada `refs/pull/958/head`.'' Git obedece y descarga todo lo necesario para
construir esa referencia, y deja un puntero al commit que quieres bajo
`.git/FETCH_HEAD`.
Puedes realizar operaciones como `git merge FETCH_HEAD` aunque el mensaje
del commit será un poco confuso. Además, si estás revisando un montón de
pull requests, se convertirá en algo tedioso.

Hay también una forma de obtener _todos_ los pull requests, y mantenerlos
actualizados cada vez que conectas al remoto. Para ello abre el fichero
`.git/config` y busca la línea `origin`. Será similar a esto:

----
[remote "origin"]
    url = https://github.com/libgit2/libgit2
    fetch = +refs/heads/*:refs/remotes/origin/*
----

La línea que comienza con `fetch =` es un ``refspec.''
Es una forma de mapear nombres del remoto con nombres de tu copia local.
Este caso concreto dice a Git, que "las cosas en el remoto bajo
`refs/heads` deben ir en mi repositorio bajo `refs/remotes/origin`."
Puedes modificar esta sección añadiendo otra refspec:

----
[remote "origin"]
    url = https://github.com/libgit2/libgit2.git
    fetch = +refs/heads/*:refs/remotes/origin/*
    fetch = +refs/pull/*/head:refs/remotes/origin/pr/*
----

Con esta última línea decimos a Git, ``Todas las referencias del tipo
`refs/pull/123/head` deben guardarse localmente como
`refs/remotes/origin/pr/123`.''
Ahora, si guardas el fichero y ejecutas un `git fetch` tendremos:

[source,console]
----
$ git fetch
# …
 * [new ref]         refs/pull/1/head -> origin/pr/1
 * [new ref]         refs/pull/2/head -> origin/pr/2
 * [new ref]         refs/pull/4/head -> origin/pr/4
# …
----

Ya tienes todos los pull request en local de forma parecida a las ramas; son
solo-lectura y se actualizan cada vez que haces un fetch. Pero hace muy fácil
probar el código de un pull request en local:

[source,console]
----
$ git checkout pr/2
Checking out files: 100% (3769/3769), done.
Branch pr/2 set up to track remote branch pr/2 from origin.
Switched to a new branch 'pr/2'
----

La referencia `refs/pull/#/merge` de GitHub representa el commit que resultaría
si pulsamos el botón ``merge''. Esto te permite probar la fusión del pull
request sin llegar a pulsar dicho botón.

===== Pull Requests sobre Pull Requests

No solamente se puede abrir Pull Requests en la rama `master`, también se
pueden abrir sobre cualquier rama de la red. De hecho, puedes poner como
objetivo otro Pull Request.

Si ves que un Pull Request va en la buena dirección y tienes una idea para
hacer un cambio que depende de él, o bien no estás seguro de que sea una
buena idea, o no tienes acceso de escritura en la rama objetivo, puedes
abrir un Pull Request directamente.

Cuando vas a abrir el Pull Request, hay una caja en la parte superior de la
página que especifica qué rama quieres usar y desde qué rama quieres hacer
la petición. Si pulsas el botón ``Edit'' en el lado derecho de la caja,
puedes cambiar no solo las ramas sino también la bifurcación.

[[_pr_targets]]
.Cambio manual de la rama o del fork en un pull request.
image::images/maint-04-target.png[objetivos de PR]

Aquí puedes fácilmente especificar la fusión de tu nueva rama en otro
Pull Request o en otrá bifurcación del proyecto.

==== Mentions and Notifications

GitHub also has a pretty nice notifications system built in that can come in handy when you have questions or need feedback from specific individuals or teams.

In any comment you can start typing a `@` character and it will begin to autocomplete with the names and usernames of people who are collaborators or contributors in the project.

.Start typing @ to mention someone.
image::images/maint-05-mentions.png[Mentions]

You can also mention a user who is not in that dropdown, but often the autocompleter can make it faster.

Once you post a comment with a user mention, that user will be notified. This means that this can be a really effective way of pulling people into conversations rather than making them poll. Very often in  Pull Requests on GitHub people will pull in other people on their teams or in their company to review an Issue or Pull Request.

If someone gets mentioned on a Pull Request or Issue, they will be ``subscribed'' to it and will continue getting notifications any time some activity occurs on it. You will also be subscribed to something if you opened it, if you're watching the repository or if you comment on something. If you no longer wish to receive notifications, there is an ``Unsubscribe'' button on the page you can click to stop receiving updates on it.

.Unsubscribe from an Issue or Pull Request.
image::images/maint-06-unsubscribe.png[Unsubscribe]

===== The Notifications Page

When we mention ``notifications'' here with respect to GitHub, we mean a specific way that GitHub tries to get in touch with you when events happen and there are a few different ways you can configure them.
If you go to the ``Notification center'' tab from the settings page, you can see some of the options you have.

.Notification center options.
image::images/maint-07-notifications.png[Notification center]

The two choices are to get notifications over ``Email'' and over ``Web'' and you can choose either, neither or both for when you actively participate in things and for activity on repositories you are watching.

====== Web Notifications

Web notifications only exist on GitHub and you can only check them on GitHub. If you have this option selected in your preferences and a notification is triggered for you, you will see a small blue dot over your notifications icon at the top of your screen as seen in <<_not_center>>.

[[_not_center]]
.Notification center.
image::images/maint-08-notifications-page.png[Notification center]

If you click on that, you will see a list of all the items you have been notified about, grouped by project. You can filter to the notifications of a specific project by clicking on it's name in the left hand sidebar. You can also acknowledge the notification by clicking the checkmark icon next to any notification, or acknowledge _all_ of the notifications in a project by clicking the checkmark at the top of the group. There is also a mute button next to each checkmark that you can click to not receive any further notifications on that item.

All of these tools are very useful for handling large numbers of notifications. Many GitHub power users will simply turn off email notifications entirely and manage all of their notifications through this screen.

====== Email Notifications

Email notifications are the other way you can handle notifications through GitHub. If you have this turned on you will get emails for each notification. We saw examples of this in <<_email_notification>> and <<_email_pr>>. The emails will also be threaded properly, which is nice if you're using a threading email client.

There is also a fair amount of metadata embedded in the headers of the emails that GitHub sends you, which can be really helpful for setting up custom filters and rules.

For instance, if we look at the actual email headers sent to Tony in the email shown in <<_email_pr>>, we will see the following among the information sent:

[source,mbox]
----
To: tonychacon/fade <fade@noreply.github.com>
Message-ID: <tonychacon/fade/pull/1@github.com>
Subject: [fade] Wait longer to see the dimming effect better (#1)
X-GitHub-Recipient: tonychacon
List-ID: tonychacon/fade <fade.tonychacon.github.com>
List-Archive: https://github.com/tonychacon/fade
List-Post: <mailto:reply+i-4XXX@reply.github.com>
List-Unsubscribe: <mailto:unsub+i-XXX@reply.github.com>,...
X-GitHub-Recipient-Address: tchacon@example.com
----

There are a couple of interesting things here. If you want to highlight or re-route emails to this particular project or even Pull Request, the information in `Message-ID` gives you all the data in `<user>/<project>/<type>/<id>` format. If this were an issue, for example, the `<type>` field would have been ``issues'' rather than ``pull''.

The `List-Post` and `List-Unsubscribe` fields mean that if you have a mail client that understands those, you can easily post to the list or ``Unsubscribe'' from the thread. That would be essentially the same as clicking the ``mute'' button on the web version of the notification or ``Unsubscribe'' on the Issue or Pull Request page itself.

It's also worth noting that if you have both email and web notifications enabled and you read the email version of the notification, the web version will be marked as read as well if you have images allowed in your mail client.

==== Special Files

There are a couple of special files that GitHub will notice if they are present in your repository.

==== README

The first is the `README` file, which can be of nearly any format that GitHub recognizes as prose. For example, it could be `README`, `README.md`, `README.asciidoc`, etc. If GitHub sees a README file in your source, it will render it on the landing page of the project.

Many teams use this file to hold all the relevant project information for someone who might be new to the repository or project. This generally includes things like:

* What the project is for
* How to configure and install it
* An example of how to use it or get it running
* The license that the project is offered under
* How to contribute to it

Since GitHub will render this file, you can embed images or links in it for added ease of understanding.

==== CONTRIBUTING

The other special file that GitHub recognizes is the `CONTRIBUTING` file. If you have a file named `CONTRIBUTING` with any file extension, GitHub will show <<_contrib_file>> when anyone starts opening a Pull Request.

[[_contrib_file]]
.Opening a Pull Request when a CONTRIBUTING file exists.
image::images/maint-09-contrib.png[Contributing notice]

The idea here is that you can specify specific things you want or don't want in a Pull Request sent to your project. This way people may actually read the guidelines before opening the Pull Request.

==== Project Administration

Generally there are not a lot of administrative things you can do with a single project, but there are a couple of items that might be of interest.

===== Changing the Default Branch

If you are using a branch other than ``master'' as your default branch that you want people to open Pull Requests on or see by default, you can change that in your repository's settings page under the ``Options'' tab.

[[_default_branch]]
.Change the default branch for a project.
image::images/maint-10-default-branch.png[Default branch]

Simply change the default branch in the dropdown and that will be the default for all major operations from then on, including which branch is checked out by default when someone clones the repository.

===== Transferring a Project

If you would like to transfer a project to another user or an organization in GitHub, there is a ``Transfer ownership'' option at the bottom of the same ``Options'' tab of your repository settings page that allows you to do this.

[[_transfer_project]]
.Transfer a project to anther GitHub user or Organization.
image::images/maint-11-transfer.png[Transfer]

This is helpful if you are abandoning a project and someone wants to take it over, or if your project is getting bigger and want to move it into an organization.

Not only does this move the repository along with all it's watchers and stars to another place, it also sets up a redirect from your URL to the new place. It will also redirect clones and fetches from Git, not just web requests.
