==== Git and TFS

(((Interoperation with other VCSs, TFS)))
(((TFS)))((("TFVC", see="TFS")))
Git is becoming popular with Windows developers, and if you're writing code on Windows, there's a good chance you're using Microsoft's Team Foundation Server (TFS).
TFS is a collaboration suite that includes defect and work-item tracking, process support for Scrum and others, code review, and version control.
There's a bit of confusion ahead: *TFS* is the server, which supports controlling source code using both Git and their own custom VCS, which they've dubbed *TFVC* (Team Foundation Version Control).
Git support is a somewhat new feature for TFS (shipping with the 2013 version), so all of the tools that predate that refer to the version-control portion as ``TFS'', even though they're mostly working with TFVC.

If you find yourself on a team that's using TFVC but you'd rather use Git as your version-control client, there's a project for you.

===== Which Tool

(((git-tf)))(((git-tfs)))
In fact, there are two: git-tf and git-tfs.

Git-tfs (found at https://github.com/git-tfs/git-tfs[]) is a .NET project, and (as of this writing) it only runs on Windows.
To work with Git repositories, it uses the .NET bindings for libgit2, a library-oriented implementation of Git which is highly performant and allows a lot of flexibility with the guts of a Git repository.
Libgit2 is not a complete implementation of Git, so to cover the difference git-tfs will actually call the command-line Git client for some operations, so there are no artificial limits on what it can do with Git repositories.
Its support of TFVC features is very mature, since it uses the Visual Studio assemblies for operations with servers.
This does mean you'll need access to those assemblies, which means you need to install a recent version of Visual Studio (any edition since version 2010, including Express since version 2012), or the Visual Studio SDK.

Git-tf (whose home is at https://gittf.codeplex.com[]) is a Java project, and as such runs on any computer with a Java runtime environment.
It interfaces with Git repositories through JGit (a JVM implementation of Git), which means it has virtually no limitations in terms of Git functions.
However, its support for TFVC is limited as compared to git-tfs – it does not support branches, for instance.

So each tool has pros and cons, and there are plenty of situations that favor one over the other.
We'll cover the basic usage of both of them in this book.

[NOTE]
====
You'll need access to a TFVC-based repository to follow along with these instructions.
These aren't as plentiful in the wild as Git or Subversion repositories, so you may need to create one of your own.
Codeplex (https://www.codeplex.com[]) or Visual Studio Online (http://www.visualstudio.com[]) are both good choices for this.
====


===== Getting Started: `git-tf`

The first thing you do, just as with any Git project, is clone.
Here's what that looks like with `git-tf`:

[source,console]
----
$ git tf clone https://tfs.codeplex.com:443/tfs/TFS13 $/myproject/Main project_git
----

The first argument is the URL of a TFVC collection, the second is of the form `$/project/branch`, and the third is the path to the local Git repository that is to be created (this last one is optional).
Git-tf can only work with one branch at a time; if you want to make checkins on a different TFVC branch, you'll have to make a new clone from that branch.

This creates a fully functional Git repository:

[source,console]
----
$ cd project_git
$ git log --all --oneline --decorate
512e75a (HEAD, tag: TFS_C35190, origin_tfs/tfs, master) Checkin message
----

This is called a _shallow_ clone, meaning that only the latest changeset has been downloaded.
TFVC isn't designed for each client to have a full copy of the history, so git-tf defaults to only getting the latest version, which is much faster.

If you have some time, it's probably worth it to clone the entire project history, using the `--deep` option:

[source,console]
----
$ git tf clone https://tfs.codeplex.com:443/tfs/TFS13 $/myproject/Main \
  project_git --deep
Username: domain\user
Password:
Connecting to TFS...
Cloning $/myproject into /tmp/project_git: 100%, done.
Cloned 4 changesets. Cloned last changeset 35190 as d44b17a
$ cd project_git
$ git log --all --oneline --decorate
d44b17a (HEAD, tag: TFS_C35190, origin_tfs/tfs, master) Goodbye
126aa7b (tag: TFS_C35189)
8f77431 (tag: TFS_C35178) FIRST
0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \
        Team Project Creation Wizard
----

Notice the tags with names like `TFS_C35189`; this is a feature that helps you know which Git commits are associated with TFVC changesets.
This is a nice way to represent it, since you can see with a simple log command which of your commits is associated with a snapshot that also exists in TFVC.
They aren't necessary (and in fact you can turn them off with `git config git-tf.tag false`) – git-tf keeps the real commit-changeset mappings in the `.git/git-tf` file.


===== Getting Started: `git-tfs`

Git-tfs cloning behaves a bit differently.
Observe:

[source,powershell]
----
PS> git tfs clone --with-branches \
    https://username.visualstudio.com/DefaultCollection \
    $/project/Trunk project_git
Initialized empty Git repository in C:/Users/ben/project_git/.git/
C15 = b75da1aba1ffb359d00e85c52acb261e4586b0c9
C16 = c403405f4989d73a2c3c119e79021cb2104ce44a
Tfs branches found:
- $/tfvc-test/featureA
The name of the local branch will be : featureA
C17 = d202b53f67bde32171d5078968c644e562f1c439
C18 = 44cd729d8df868a8be20438fdeeefb961958b674
----

Notice the `--with-branches` flag.
Git-tfs is capable of mapping TFVC branches to Git branches, and this flag tells it to set up a local Git branch for every TFVC branch.
This is highly recommended if you've ever branched or merged in TFS, but it won't work with a server older than TFS 2010 – before that release, ``branches'' were just folders, so git-tfs can't tell them from regular folders.

Let's take a look at the resulting Git repository:

[source,powershell]
----
PS> git log --oneline --graph --decorate --all
* 44cd729 (tfs/featureA, featureA) Goodbye
* d202b53 Branched from $/tfvc-test/Trunk
* c403405 (HEAD, tfs/default, master) Hello
* b75da1a New project
PS> git log -1
commit c403405f4989d73a2c3c119e79021cb2104ce44a
Author: Ben Straub <ben@straub.cc>
Date:   Fri Aug 1 03:41:59 2014 +0000

    Hello

    git-tfs-id: [https://username.visualstudio.com/DefaultCollection]$/myproject/Trunk;C16
----

There are two local branches, `master` and `featureA`, which represent the initial starting point of the clone (`Trunk` in TFVC) and a child branch (`featureA` in TFVC).
You can also see that the `tfs` ``remote'' has a couple of refs too: `default` and `featureA`, which represent TFVC branches.
Git-tfs maps the branch you cloned from to `tfs/default`, and others get their own names.

Another thing to notice is the `git-tfs-id:` lines in the commit messages.
Instead of tags, git-tfs uses these markers to relate TFVC changesets to Git commits.
This has the implication that your Git commits will have a different SHA-1 hash before and after they have been pushed to TFVC.

===== Git-tf[s] Workflow

[NOTE]
====
Regardless of which tool you're using, you should set a couple of Git configuration values to avoid running into issues.

[source,console]
----
$ git config set --local core.ignorecase=true
$ git config set --local core.autocrlf=false
----
====

The obvious next thing you're going to want to do is work on the project.
TFVC and TFS have several features that may add complexity to your workflow:

. Feature branches that aren't represented in TFVC add a bit of complexity.
  This has to do with the *very* different ways that TFVC and Git represent branches.
. Be aware that TFVC allows users to ``checkout'' files from the server, locking them so nobody else can edit them.
  This obviously won't stop you from editing them in your local repository, but it could get in the way when it comes time to push your changes up to the TFVC server.
. TFS tiene el concepto de comprobaciones "compuertas", donde un ciclo de prueba de compilación TFS debe completarse satisfactoriamente antes de permitir el registro.
  Utiliza la función `` shelve '' en TFVC, que no cubrimos en detalle aquí.
    Puede falsificar esto de forma manual con git-tf, y git-tfs proporciona el comando `checkintool` que es sensible a la puerta.

En aras de la brevedad, lo que trataremos aquí es el camino feliz, qué pasos laterales o evita la mayoría de estos problemas.

===== Flujo de trabajo del: `git-tf`


Digamos que has hecho algo de trabajo, has hecho un par de confirmaciones de Git en `master` y estás listo para compartir tu progreso en el servidor de TFVC.
Aquí está nuestro repositorio de Git:

[source,console]
----
$ git log --oneline --graph --decorate --all
* 4178a82 (HEAD, master) update code
* 9df2ae3 update readme
* d44b17a (tag: TFS_C35190, origin_tfs/tfs) Goodbye
* 126aa7b (tag: TFS_C35189)
* 8f77431 (tag: TFS_C35178) FIRST
* 0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \
          Team Project Creation Wizard
----

Queremos tomar la instantánea que está en la confirmación `4178a82` y subirla al servidor TFVC.
Lo primero es lo primero: veamos si alguno de nuestros compañeros de equipo hizo algo desde la última vez que nos conectamos:

[source,console]
----
$ git tf fetch
Username: domain\user
Password:
Connecting to TFS...
Fetching $/myproject at latest changeset: 100%, done.
Downloaded changeset 35320 as commit 8ef06a8. Updated FETCH_HEAD.
$ git log --oneline --graph --decorate --all
* 8ef06a8 (tag: TFS_C35320, origin_tfs/tfs) just some text
| * 4178a82 (HEAD, master) update code
| * 9df2ae3 update readme
|/
* d44b17a (tag: TFS_C35190) Goodbye
* 126aa7b (tag: TFS_C35189)
* 8f77431 (tag: TFS_C35178) FIRST
* 0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \
          Team Project Creation Wizard
----

Parece que alguien más está trabajando, también, y ahora tenemos una historia divergente.
Aquí es donde brilla el Git, pero tenemos dos opciones de cómo proceder:

. Hacer una confirmación de fusión se siente natural como un usuario de Git (después de todo, eso es lo que hace `git pull`), y git-tf puede hacer esto por ti con un simple` git tf pull`.
  Tenga en cuenta, sin embargo, que TFVC no piensa de esta manera, y si empuja la fusión se compromete su historia comenzará a verse diferente en ambos lados, lo que puede ser confuso.
  Sin embargo, si planea enviar todos sus cambios como un solo conjunto de cambios, esta es probablemente la opción más fácil.
. Rebasing hace que nuestro historial de compromisos sea lineal, lo que significa que tenemos la opción de convertir cada una de nuestras confirmaciones de Git en un conjunto de cambios de TFVC.
  Como esto deja la mayoría de las opciones abiertas, le recomendamos que lo haga de esta manera; git-tf incluso te lo facilita con `git tf pull --rebase`.

La decisión es tuya:
Para este ejemplo, vamos a rebasar:

[source,console]
----
$ git rebase FETCH_HEAD
First, rewinding head to replay your work on top of it...
Applying: update readme
Applying: update code
$ git log --oneline --graph --decorate --all
* 5a0e25e (HEAD, master) update code
* 6eb3eb5 update readme
* 8ef06a8 (tag: TFS_C35320, origin_tfs/tfs) just some text
* d44b17a (tag: TFS_C35190) Goodbye
* 126aa7b (tag: TFS_C35189)
* 8f77431 (tag: TFS_C35178) FIRST
* 0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \
          Team Project Creation Wizard
----

Ahora estamos listos para hacer una comprobación en el servidor de TFVC.
Git-tf le da la opción de hacer un único conjunto de cambios que represente todos los cambios desde el último (`--shallow`, que es el predeterminado) y crear un nuevo conjunto de cambios para cada confirmación de Git (` --deep`).
Para este ejemplo, crearemos un solo conjunto de cambios:

[source,console]
----
$ git tf checkin -m 'Updating readme and code'
Username: domain\user
Password:
Connecting to TFS...
Checking in to $/myproject: 100%, done.
Checked commit 5a0e25e in as changeset 35348
$ git log --oneline --graph --decorate --all
* 5a0e25e (HEAD, tag: TFS_C35348, origin_tfs/tfs, master) update code
* 6eb3eb5 update readme
* 8ef06a8 (tag: TFS_C35320) just some text
* d44b17a (tag: TFS_C35190) Goodbye
* 126aa7b (tag: TFS_C35189)
* 8f77431 (tag: TFS_C35178) FIRST
* 0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \
          Team Project Creation Wizard
----

Hay una nueva etiqueta `TFS_C35348`, que indica que TFVC está almacenando la misma instantánea exacta que la confirmación` 5a0e25e`.
Es importante tener en cuenta que no todas las confirmaciones del Git deben tener una contraparte exacta en TFVC; el compromiso `6eb3eb5`, por ejemplo, no existe en ninguna parte del servidor.

Ese es el flujo de trabajo principal.
Hay un par de otras consideraciones que querrás tener en cuenta:

* No hay ramificación.
Git-tf solo puede crear repositorios Git de una rama TFVC a la vez.
* Colabora con TFVC o Git, pero no con ambos.
  Los diferentes clones de git-tf del mismo repositorio de TFVC pueden tener diferentes hash de confirmación de SHA-1, lo que provocará innumerables dolores de cabeza.
* Si el flujo de trabajo de su equipo incluye la colaboración en Git y la sincronización periódica con TFVC, solo conéctese a TFVC con uno de los repositorios de Git.


===== Flujo de trabajo: `git-tfs`

Veamos el mismo escenario usando git-tfs.
Aquí están las nuevas confirmaciones que hemos realizado en la rama `master` en nuestro repositorio de Git:

[source,powershell]
----
PS> git log --oneline --graph --all --decorate
* c3bd3ae (HEAD, master) update code
* d85e5a2 update readme
| * 44cd729 (tfs/featureA, featureA) Goodbye
| * d202b53 Branched from $/tfvc-test/Trunk
|/
* c403405 (tfs/default) Hello
* b75da1a New project
----

Ahora veamos si alguien más ha hecho un trabajo mientras estábamos hackeando:

[source,powershell]
----
PS> git tfs fetch
C19 = aea74a0313de0a391940c999e51c5c15c381d91d
PS> git log --all --oneline --graph --decorate
* aea74a0 (tfs/default) update documentation
| * c3bd3ae (HEAD, master) update code
| * d85e5a2 update readme
|/
| * 44cd729 (tfs/featureA, featureA) Goodbye
| * d202b53 Branched from $/tfvc-test/Trunk
|/
* c403405 Hello
* b75da1a New project
----

Sí, resulta que nuestro compañero de trabajo ha agregado un nuevo conjunto de cambios de TFVC, que se muestra como el nuevo compromiso `aea74a0`, y la rama remota` tfs / default` se ha movido.

Al igual que con git-tf, tenemos dos opciones fundamentales sobre cómo resolver esta historia divergente:

. Rebase para preservar una historia lineal.
. Fusiona para preservar lo que realmente sucedió.

En este caso, haremos un checkin '' profundo '', donde cada confirmación del Git se convierte en un conjunto de cambios de TFVC, por lo que queremos volver a establecer la base.

[source,powershell]
----
PS> git rebase tfs/default
First, rewinding head to replay your work on top of it...
Applying: update readme
Applying: update code
PS> git log --all --oneline --graph --decorate
* 10a75ac (HEAD, master) update code
* 5cec4ab update readme
* aea74a0 (tfs/default) update documentation
| * 44cd729 (tfs/featureA, featureA) Goodbye
| * d202b53 Branched from $/tfvc-test/Trunk
|/
* c403405 Hello
* b75da1a New project
----

Ahora estamos listos para completar nuestra contribución al registrar nuestro código en el servidor TFVC.
Usaremos el comando `rcheckin` aquí para crear un conjunto de cambios TFVC para cada commit de Git en la ruta de HEAD a la primera rama remota` tfs` encontrada (el comando `checkin` solo crearía un conjunto de cambios, más o menos como aplastar a Git se compromete).

[source,powershell]
----
PS> git tfs rcheckin
Working with tfs remote: default
Fetching changes from TFS to minimize possibility of late conflict...
Starting checkin of 5cec4ab4 'update readme'
 add README.md
C20 = 71a5ddce274c19f8fdc322b4f165d93d89121017
Done with 5cec4ab4b213c354341f66c80cd650ab98dcf1ed, rebasing tail onto new TFS-commit...
Rebase done successfully.
Starting checkin of b1bf0f99 'update code'
 edit .git\tfs\default\workspace\ConsoleApplication1/ConsoleApplication1/Program.cs
C21 = ff04e7c35dfbe6a8f94e782bf5e0031cee8d103b
Done with b1bf0f9977b2d48bad611ed4a03d3738df05ea5d, rebasing tail onto new TFS-commit...
Rebase done successfully.
No more to rcheckin.
PS> git log --all --oneline --graph --decorate
* ff04e7c (HEAD, tfs/default, master) update code
* 71a5ddc update readme
* aea74a0 update documentation
| * 44cd729 (tfs/featureA, featureA) Goodbye
| * d202b53 Branched from $/tfvc-test/Trunk
|/
* c403405 Hello
* b75da1a New project
----

Observe cómo después de cada registro exitoso en el servidor TFVC, git-tfs vuelve a basar el trabajo restante en lo que acaba de hacer.
Esto se debe a que está agregando el campo `git-tfs-id` al final de los mensajes de confirmación, lo que cambia los valores hash SHA-1.
Esto es exactamente como se diseñó, y no hay nada de qué preocuparse, pero debe saber que está sucediendo, especialmente si comparte Git commits con otros.

TFS tiene muchas características que se integran con su sistema de control de versiones, como elementos de trabajo, revisores designados, registros bloqueados, etc.
Puede ser engorroso trabajar con estas características usando solo una herramienta de línea de comandos, pero afortunadamente git-tfs le permite iniciar una herramienta gráfica de registro muy fácilmente:

[source,powershell]
----
PS> git tfs checkintool
PS> git tfs ct
----

Se parece un poco a esto:

.La herramienta de registro de git-tfs.
image::images/git-tfs-ct.png[The git-tfs checkin tool.]

Esto resultará familiar para los usuarios de TFS, ya que es el mismo diálogo que se inicia desde Visual Studio.

Git-tfs también le permite controlar ramas de TFVC desde su repositorio de Git.
Como ejemplo, creemos uno:

[source,powershell]
----
PS> git tfs branch $/tfvc-test/featureBee
The name of the local branch will be : featureBee
C26 = 1d54865c397608c004a2cadce7296f5edc22a7e5
PS> git log --oneline --graph --decorate --all
* 1d54865 (tfs/featureBee) Creation branch $/myproject/featureBee
* ff04e7c (HEAD, tfs/default, master) update code
* 71a5ddc update readme
* aea74a0 update documentation
| * 44cd729 (tfs/featureA, featureA) Goodbye
| * d202b53 Branched from $/tfvc-test/Trunk
|/
* c403405 Hello
* b75da1a New project
----

Crear una rama en TFVC significa agregar un conjunto de cambios donde esa rama ahora existe, y esto se proyecta como una confirmación de Git.
Tenga en cuenta también que git-tfs *created* la rama remota `tfs / featureBee`, pero` HEAD` todavía apunta a `master`.
Si desea trabajar en la rama recién acuñada, querrá basar sus nuevas confirmaciones en la confirmación `1d54865`, tal vez creando una rama de tema a partir de esa confirmación.


===== Resumen de Git y TFS

Git-tf y Git-tfs son excelentes herramientas para interactuar con un servidor TFVC.
Le permiten usar el poder de Git localmente, evitar tener que realizar un viaje de ida y vuelta al servidor central de TFVC, y hacer que su vida como desarrollador sea mucho más fácil, sin forzar a todo su equipo a migrar a Git.
Si está trabajando en Windows (lo cual es probable si su equipo está usando TFS), probablemente quiera usar git-tfs, ya que su conjunto de características es más completo, pero si está trabajando en otra plataforma, ' Estaré usando git-tf, que es más limitado.
Al igual que con la mayoría de las herramientas de este capítulo, debe elegir uno de estos sistemas de control de versiones para que sea canónico y usar el otro de forma subordinada: Git o TFVC deberían ser el centro de colaboración, pero no ambos.
