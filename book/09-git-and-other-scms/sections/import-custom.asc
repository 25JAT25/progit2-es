[[_custom_importer]]
==== Un importador personalizado

(((git commands, fast-import)))
(((Importing, from others)))
Si su sistema no es uno de los anteriores, debe buscar un importador en línea: los importadores de calidad están disponibles para muchos otros sistemas, incluidos CVS, Clear Case, Visual Source Safe e incluso un directorio de archivos.
Si ninguna de estas herramientas funciona para usted, tiene una herramienta más oscura, o si no necesita un proceso de importación más personalizado, debe usar `git fast-import`.
Este comando lee instrucciones simples de stdin para escribir datos específicos de Git.
Es mucho más fácil crear objetos Git de esta manera que ejecutar los comandos Git sin formato o intentar escribir los objetos sin procesar (ver << _ git_internals >> para más información).
De esta forma, puede escribir un script de importación que lea la información necesaria del sistema desde el que está importando e imprima instrucciones sencillas para la salida estándar.
A continuación, puede ejecutar este programa y canalizar su salida a través de `git fast-import`.

Para demostrarlo rápidamente, escribirás un importador simple.
Supongamos que trabaja en `current`, hace una copia de seguridad de su proyecto copiando ocasionalmente el directorio en un directorio de copia de seguridad` back_YYYY_MM_DD` con marca de tiempo y quiere importarlo a Git.
Su estructura de directorios se vería así:

[source,console]
----
$ ls /opt/import_from
back_2014_01_02
back_2014_01_04
back_2014_01_14
back_2014_02_03
current
----

Para importar un directorio de Git, necesita revisar cómo Git almacena sus datos.
Como recordarán, Git es fundamentalmente una lista vinculada de objetos de compromiso que apuntan a una instantánea del contenido.
Todo lo que tiene que hacer es decirle al `fast-import` qué son las instantáneas de su contenido, qué datos de los puntos de confirmaciones y el orden en que ingresarán.
Su estrategia será pasar a través de las instantáneas de a una por vez y crear compromisos con los contenidos de cada directorio, vinculando cada compromiso con el anterior.

Como hicimos en << _ an_example_git_enforced_policy >>, escribiremos esto en Ruby, porque es con lo que generalmente trabajamos y tiende a ser fácil de leer.
Puede escribir este ejemplo con bastante facilidad en cualquier cosa con la que esté familiarizado; solo necesita imprimir la información adecuada en `stdout`.
Y, si está ejecutando en Windows, esto significa que tendrá que tener especial cuidado de no presentar retornos de carrete al final de sus líneas - git fast-import es muy particular acerca de querer feed lines (LF) y no el carriage Return Line Feed (CRLF) que usa Windows.

Para comenzar, cambiará al directorio de destino e identificará cada subdirectorio, cada uno de los cuales es una instantánea que desea importar como una confirmación.
Cambiará a cada subdirectorio e imprimirá los comandos necesarios para exportarlo.
Su ciclo principal básico se ve así:

[source,ruby]
----
last_mark = nil

# loop through the directories
Dir.chdir(ARGV[0]) do
  Dir.glob("*").each do |dir|
    next if File.file?(dir)

    # move into the target directory
    Dir.chdir(dir) do
      last_mark = print_export(dir, last_mark)
    end
  end
end
----

Ejecuta `print_export` dentro de cada directorio, que toma el manifiesto y la marca de la instantánea anterior y devuelve el manifiesto y la marca de este; de esa manera, puedes vincularlos adecuadamente.
`` Mark '' es el término `fast-import` para un identificador que le das a una confirmación; a medida que crea confirmaciones, le da a cada una una marca que puede usar para vincularla con otras confirmaciones.
Entonces, lo primero que debe hacer en su método `print_export` es generar una marca desde el nombre del directorio:

[source,ruby]
----
mark = convert_dir_to_mark(dir)
----

Lo hará creando una matriz de directorios y utilizando el valor del índice como la marca, porque una marca debe ser un número entero.
Tu método se ve así:

[source,ruby]
----
$marks = []
def convert_dir_to_mark(dir)
  if !$marks.include?(dir)
    $marks << dir
  end
  ($marks.index(dir) + 1).to_s
end
----

Ahora que tiene una representación entera de su confirmación, necesita una fecha para los metadatos de confirmación.
Como la fecha se expresa en el nombre del directorio, lo analizará.
La siguiente línea en su archivo `print_export` es

[source,ruby]
----
date = convert_dir_to_date(dir)
----

donde `convert_dir_to_date` se define como

[source,ruby]
----
def convert_dir_to_date(dir)
  if dir == 'current'
    return Time.now().to_i
  else
    dir = dir.gsub('back_', '')
    (year, month, day) = dir.split('_')
    return Time.local(year, month, day).to_i
  end
end
----

Eso devuelve un valor entero para la fecha de cada directorio.
La última parte de metainformación que necesita para cada confirmación es la información del confirmador, que se codifica en una variable global:

[source,ruby]
----
$author = 'John Doe <john@example.com>'
----

Ahora está listo para comenzar a imprimir los datos de confirmación para su importador.
La información inicial indica que está definiendo un objeto de confirmación y en qué rama está, seguido de la marca que ha generado, la información del confirmador y el mensaje de confirmación, y luego la confirmación anterior, si corresponde.
El código se ve así:

[source,ruby]
----
# print the import information
puts 'commit refs/heads/master'
puts 'mark :' + mark
puts "committer #{$author} #{date} -0700"
export_data('imported from ' + dir)
puts 'from :' + last_mark if last_mark
----

Usted codifica la zona horaria (-0700) porque hacerlo así será más fácil.
Si está importando desde otro sistema, debe especificar la zona horaria como un desplazamiento.
El mensaje de confirmación debe expresarse en un formato especial:

[source]
----
data (size)\n(contents)
----

El formato consiste en la palabra datos, el tamaño de los datos a leer, una nueva línea y finalmente los datos.
Debido a que necesita usar el mismo formato para especificar el contenido del archivo más adelante, crea un método auxiliar, `export_data`:

[source,ruby]
----
def export_data(string)
  print "data #{string.size}\n#{string}"
end
----

Lo único que queda es especificar el contenido del archivo para cada instantánea.
Esto es fácil, porque tiene cada uno en un directorio: puede imprimir el comando `deleteall` seguido de los contenidos de cada archivo en el directorio.
Git luego grabará cada instantánea apropiadamente:

[source,ruby]
----
puts 'deleteall'
Dir.glob("**/*").each do |file|
  next if !File.file?(file)
  inline_data(file)
end
----

Nota: Debido a que muchos sistemas piensan en sus revisiones como cambios de una confirmación a otra, la importación rápida también puede tomar comandos con cada confirmación para especificar qué archivos se han agregado, eliminado o modificado y cuáles son los contenidos nuevos.
Puede calcular las diferencias entre las instantáneas y proporcionar solo estos datos, pero hacerlo es más complejo; también puede darle todos los datos a Git y dejar que se resuelva.
Si esto se adapta mejor a sus datos, consulte la página del comando `fast-import` para obtener detalles sobre cómo proporcionar sus datos de esta manera.

El formato para listar los nuevos contenidos del archivo o especificar un archivo modificado con los nuevos contenidos es el siguiente:

[source]
----
M 644 inline path/to/file
data (size)
(file contents)
----

Aquí, 644 es el modo (si tiene archivos ejecutables, necesita detectar y especificar 755 en su lugar), y en línea dice que listará el contenido inmediatamente después de esta línea.
Su método `inline_data` tiene este aspecto:

[source,ruby]
----
def inline_data(file, code = 'M', mode = '644')
  content = File.read(file)
  puts "#{code} #{mode} inline #{file}"
  export_data(content)
end
----

Reutilizas el método `export_data` que definiste antes, porque es igual a la forma en que especificaste los datos del mensaje de confirmación.

Lo último que debe hacer es devolver la marca actual para que pueda pasarla a la siguiente iteración:

[source,ruby]
----
return mark
----

[NOTA]
====
Si está ejecutando en Windows, deberá asegurarse de agregar un paso adicional.
Como se mencionó anteriormente, Windows usa CRLF para nuevos caracteres de línea mientras que git fast-import solo espera LF.
Para evitar este problema y hacer que git sea rápido, importe feliz, necesita decirle a ruby que use LF en lugar de CRLF:

[source,ruby]
----
$stdout.binmode
----
====

Eso es.
Aquí está todo el script.


[source,ruby]
----
#!/usr/bin/env ruby

$stdout.binmode
$author = "John Doe <john@example.com>"

$marks = []
def convert_dir_to_mark(dir)
    if !$marks.include?(dir)
        $marks << dir
    end
    ($marks.index(dir)+1).to_s
end


def convert_dir_to_date(dir)
    if dir == 'current'
        return Time.now().to_i
    else
        dir = dir.gsub('back_', '')
        (year, month, day) = dir.split('_')
        return Time.local(year, month, day).to_i
    end
end

def export_data(string)
    print "data #{string.size}\n#{string}"
end

def inline_data(file, code='M', mode='644')
    content = File.read(file)
    puts "#{code} #{mode} inline #{file}"
    export_data(content)
end

def print_export(dir, last_mark)
    date = convert_dir_to_date(dir)
    mark = convert_dir_to_mark(dir)

    puts 'commit refs/heads/master'
    puts "mark :#{mark}"
    puts "committer #{$author} #{date} -0700"
    export_data("imported from #{dir}")
    puts "from :#{last_mark}" if last_mark

    puts 'deleteall'
    Dir.glob("**/*").each do |file|
        next if !File.file?(file)
        inline_data(file)
    end
    mark
end


# Loop through the directories
last_mark = nil
Dir.chdir(ARGV[0]) do
    Dir.glob("*").each do |dir|
        next if File.file?(dir)

        # move into the target directory
        Dir.chdir(dir) do
            last_mark = print_export(dir, last_mark)
        end
    end
end
----

Si ejecuta este script, obtendrá un contenido que se ve así:

[source,console]
----
$ ruby import.rb /opt/import_from
commit refs/heads/master
mark :1
committer John Doe <john@example.com> 1388649600 -0700
data 29
imported from back_2014_01_02deleteall
M 644 inline README.md
data 28
# Hello

This is my readme.
commit refs/heads/master
mark :2
committer John Doe <john@example.com> 1388822400 -0700
data 29
imported from back_2014_01_04from :1
deleteall
M 644 inline main.rb
data 34
#!/bin/env ruby

puts "Hey there"
M 644 inline README.md
(...)
----

Para ejecutar el importador, canalice esta salida a través de `git fast-import` mientras esté en el directorio de Git que desea importar.
Puede crear un nuevo directorio y luego ejecutar `git init` en él para un punto de partida, y luego ejecutar su secuencia de comandos:

[source,console]
----
$ git init
Initialized empty Git repository in /opt/import_to/.git/
$ ruby import.rb /opt/import_from | git fast-import
git-fast-import statistics:
---------------------------------------------------------------------
Alloc'd objects:       5000
Total objects:           13 (         6 duplicates                  )
      blobs  :            5 (         4 duplicates          3 deltas of          5 attempts)
      trees  :            4 (         1 duplicates          0 deltas of          4 attempts)
      commits:            4 (         1 duplicates          0 deltas of          0 attempts)
      tags   :            0 (         0 duplicates          0 deltas of          0 attempts)
Total branches:           1 (         1 loads     )
      marks:           1024 (         5 unique    )
      atoms:              2
Memory total:          2344 KiB
       pools:          2110 KiB
     objects:           234 KiB
---------------------------------------------------------------------
pack_report: getpagesize()            =       4096
pack_report: core.packedGitWindowSize = 1073741824
pack_report: core.packedGitLimit      = 8589934592
pack_report: pack_used_ctr            =         10
pack_report: pack_mmap_calls          =          5
pack_report: pack_open_windows        =          2 /          2
pack_report: pack_mapped              =       1457 /       1457
---------------------------------------------------------------------
----

Como puede ver, cuando se completa con éxito, le da un montón de estadísticas sobre lo que logró.
En este caso, importó 13 objetos en total para 4 confirmaciones en 1 rama.
Ahora, puede ejecutar `git log` para ver su nuevo historial:

[source,console]
----
$ git log -2
commit 3caa046d4aac682a55867132ccdfbe0d3fdee498
Author: John Doe <john@example.com>
Date:   Tue Jul 29 19:39:04 2014 -0700

    imported from current

commit 4afc2b945d0d3c8cd00556fbe2e8224569dc9def
Author: John Doe <john@example.com>
Date:   Mon Feb 3 01:00:00 2014 -0700

    imported from back_2014_02_03
----

Aquí tienes: un repositorio de Git agradable y limpio.
Es importante tener en cuenta que nada está desprotegido; al principio no tiene ningún archivo en su directorio de trabajo.
Para obtenerlos, debe restablecer su sucursal a donde es ahora `master`:

[source,console]
----
$ ls
$ git reset --hard master
HEAD is now at 3caa046 imported from current
$ ls
README.md main.rb
----

Puede hacer mucho más con la herramienta `importación rápida`: maneja diferentes modos, datos binarios, múltiples ramas y combinaciones, etiquetas, indicadores de progreso y más.
Hay varios ejemplos de escenarios más complejos disponibles en el directorio `contrib / fast-import` del código fuente de Git.
