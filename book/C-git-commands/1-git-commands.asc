[appendix]
== Comandos de Git

A lo largo del libro hemos introducido docenas de comandos de Git y nos hemos esforzado para introducirlos dentro de una especie de narrativa, añadiendo más comandos a la historia poco a poco. Sin embargo, esto nos deja con ejemplos de uso de los comandos algo dispersos por todo el libro. 

En este apéndice, repasaremos todos los comandos de Git que hemos tratado a lo largo del libro, agrupados por el uso que se les ha dado. Vamos a hablar de lo que hace cada comando de manera muy general y a continuación señalaremos en qué parte del libro puedes encontrar un uso de él.

=== Configuración

Hay dos comandos que se usan bastante, desde las primeras invocaciones de Git hasta el ajuste y referenciamiento diario, los comandos `config` y `help`.

==== git config

Git tiene una forma predeterminada de hacer cientos de cosas. Para muchas de estas cosas, puedes indicar a Git hacerlas por defecto de una manera diferente, o establecer tus preferencias. Esto incluye todo, desde decir a Git cuál es tu nombre a las preferencias de color específicas del terminal o qué editor utilizar. Hay varios archivos desde los que este comando lee y a los que escribe, así puedes establecer los valores a nivel global o hacia abajo para repositorios específicos.

El comando `git config` se ha utilizado en casi todos los capítulos del libro.

En <<_first_time>> lo usamos para especificar nuestro nombre, dirección de correo electrónico y editor de preferencia antes incluso de comenzar a utilizar Git.

En <<_git_aliases>> mostramos cómo se puede utilizar para crear comandos abreviados que se expanden para secuencias largas de opciones para no tener que escribirlas cada vez.

En <<_rebasing>> lo usamos para hacer `--rebase` predeterminado cuando se ejecuta `git pull`.

En <<_credential_caching>> lo usamos para establecer un almacén predeterminado para tus contraseñas HTTP.

En <<_keyword_expansion>> mostramos como configurar filtros sucios y limpios sobre contenido que entra y sale de Git.

Finalmente, básicamente la totalidad de <<_git_config>> está dedicado al comando.

==== git help

El comando `git help` se utiliza para presentarte toda la documentación contenida con Git sobre cualquier comando. A pesar de que estamos dando una visión general de la mayoría de los más populares en este apéndice, para obtener una lista completa de todas las posibles opciones e indicadores para cada orden, siempre se puede ejecutar `git help <command>`.

Introducimos el comando `git help` en <<_git_help>> y te mostramos cómo utilizarlo para encontrar más información sobre el `git shell` en <<_setting_up_server>>.


=== Obtener y Crear Proyectos

Hay dos maneras de obtener un repositorio Git. Una de ellas es copiarlo desde un repositorio existente en la red o en otro lugar y la otra es crear uno nuevo en un directorio existente.

==== git init

Para tomar un directorio y convertirlo en un nuevo repositorio Git en el que puedas empezar a controlar sus versiones, simplemente puedes ejecutar `git init`.

En primer lugar, introducimos esto en <<_getting_a_repo>>, donde mostramos la creación de un nuevo repositorio para empezar a trabajar.

Hablamos brevemente acerca de cómo puedes cambiar la rama por defecto desde ``master'' en <<_remote_branches>>.

Usamos este comando para crear un repositorio desnudo (bare) vacío para un servidor en <<_bare_repo>>.

Por último, examinamos algunos de los detalles de lo que realmente hace detrás de escena en <<_plumbing_porcelain>>.

==== git clone

El comando 'git clone` es en realidad una especie de envoltura alrededor de varios otros comandos. Éste crea un nuevo directorio, entra en él y ejecuta `git init` para que sea un repositorio vacío de Git, añade uno remoto (`git remote add`) hacia la dirección URL que se le pasa (por defecto llamado `origin`), ejecuta un `git fetch` de ese repositorio remoto y después activa el último commit en el directorio de trabajo con `git checkout`.

El comando `git clone` es utilizado en docenas de lugares a lo largo del libro, pero sólo enumeraremos algunos lugares interesantes.

Básicamente se introdujo y se explicó en <<_git_cloning>>, donde examinamos algunos ejemplos.

En <<_git_on_the_server>> nos fijamos en el uso de la opción `--bare` para crear una copia de un repositorio Git sin directorio de trabajo.

En <<_bundling>> lo usamos para desempaquetar un repositorio Git empaquetado (bundle).

Finalmente, en <<_cloning_submodules>> aprendemos la opción `--recursive` para realizar la clonación de un repositorio con submódulos un poco más simple. 

Aunque se usa en muchos otros lugares a través del libro, estos son los que son algo únicos o donde se utiliza en formas que son un poco diferentes.

=== Seguimiento Básico

Para el flujo de trabajo básico de la preparación de contenido y su confirmación a su historia, hay sólo unos pocos comandos básicos.

==== git add

El comando `git add` añade contenido del directorio de trabajo al área de ensayo (staging area o ''index'') para la próxima confirmación. Cuando se ejecuta el comando `git commit`, éste, de forma predeterminada, sólo mira en esta área de ensayo, por lo que `git add` se utiliza para fabricar exactamente lo que te gustaría fuese tu próxima instantánea a confirmar.

Este comando es un comando increíblemente importante en Git y se menciona o se utiliza docenas de veces en este libro. Vamos a cubrir rápidamente algunos de los usos únicos que se pueden encontrar.

En primer lugar, introducimos y explicamos `git add` en detalle en <<_tracking_files>>.

Mostramos como usarlo para resolver conflictos de fusión en <<_basic_merge_conflicts>>.

Repasamos su uso para seguir de forma interactiva sólo partes específicas de un archivo modificado en <<_interactive_staging>>.

Por último, lo emulamos en un bajo nivel en <<_tree_objects>>, por lo que podemos tener una idea de lo que está haciendo detrás de escena.

==== git status

El comando `git status` te mostrará los diferentes estados de los archivos en tu directorio de trabajo y área de ensayo. Qué archivos están modificados y sin seguimiento y cuáles con seguimiento pero no confirmados aún. En su forma normal, también te mostrará algunos consejos básicos sobre cómo mover archivos entre estas etapas.

Primero cubrimos `status` en <<_checking_status>>, tanto en su forma básica como simplificada. Mientras lo utilizamos a lo largo del libro, prácticamente todo lo que puedes hacer con el comando `git status` está cubierto allí.

==== git diff

El comando `git diff` se utiliza cuando deseas ver las diferencias entre dos árboles. Esto prodría ser la diferencia entre tu entorno de trabajo y tu área de ensayo (`git diff` por sí mismo), entre tu área de ensayo y tu última confirmación o commit (`git diff --staged`), o entre dos confirmaciones (`git diff master branchB`).

En primer lugar, vemos el uso básico de `git diff` en <<_git_diff_staged>>, donde mostramos cómo ver que cambios tienen seguimiento y cuáles no tienen seguimiento aún.

Lo usamos para buscar posibles problemas con espacios en blanco antes de confirmar con la opción `--check` en <<_commit_guidelines>>.

Vemos cómo comprobar las diferencias entre ramas de manera más eficaz con la sintaxis `git diff A...B` en <<_what_is_introduced>>.

Lo usamos para filtrar diferencias en espacios en blanco con `-w` y como comparar diferentes etapas de archivos en conflicto con `--theirs`, `--ours` y `--base` en <<_advanced_merging>>.

Finalmente, lo usamos para realmente comparar cambios en submódulos con `--submodule` en <<_starting_submodules>>.

==== git difftool

El comando `git difftool` simplemente lanza una herramienta externa para mostrar la diferencia entre dos árboles, en caso de que desees utilizar algo que no sea el comando`git diff` incorporado.

Mencionamos sólo brevemente esto en <<_git_diff_staged >>.

==== git commit

El comando `git commit` toma todos los contenidos de los archivos a los que se les realiza el seguimiento con `git add` y registra una nueva instantánea permanente en la base de datos y luego avanza el puntero de la rama en la rama actual.

En primer lugar, cubrimos los fundamentos en <<_committing_changes>>. Allí también mostramos cómo utilizar el indicador `-a` para saltarse el paso `git add`  en los flujos de trabajo diarios y cómo utilizar el indicador `-m` para pasar un mensaje de confirmación en la línea de comandos en lugar de lanzar un editor.

En <<_undoing>> cubrimos el uso de la opción `--amend` para deshacer el commit más reciente.

En <<_git_branches_overview>>, entramos en mucho mayor detalle en lo que `git commit` hace y por qué lo hace así.

Consideramos como firmar criptográficamente commits con el indicador `-S` en <<_signing_commits>>.

Finalmente, echamos un vistazo a lo que el comando `git commit` hace en segundo plano y cómo se implementa realmente en <<_git_commit_objects>>.

==== git reset

El comando `git reset` se utiliza sobre todo para deshacer las cosas, como posiblemente puedes deducir por el verbo. Se mueve alrededor del puntero `HEAD` y opcionalmente cambia el `index` o área de ensayo y también puede cambiar opcionalmente el directorio de trabajo si se utiliza `--hard`. Esta última opción hace posible que este comando pueda perder tu trabajo si se usa incorrectamente, por lo que asegúrese de entenderlo antes de usarlo.

En primer lugar, cubrimos efectivamente el uso más simple de `git reset` en <<_unstaging>>, donde lo usamos para dejar de hacer seguimiento (unstage) de un archivo sobre el que habíamos ejecutado `git add`.

A continuación, lo cubrimos con bastante detalle en <<_git_reset>>, que está completamente dedicado a la explicación de este comando.

Utilizamos `git reset --hard` para abortar una fusión en <<_abort_merge>>, donde también usamos `git merge --abort`, el cual es una especie de envoltorio para el comando `git reset`.

==== git rm

El comando `git rm` se utiliza para eliminar archivos del área de ensayo y el directorio de trabajo para Git. Es similar a `git add` en que pone en escena una eliminación de un archivo para la próxima confirmación. 

Cubrimos el comando `git rm` con cierto detalle en <<_removing_files >>, incluyendo la eliminación de archivos de forma recursiva y sólo la eliminación de archivos desde el área de ensayo, pero dejándolos en el directorio de trabajo con `--cached`.

El único otro uso diferente de `git rm` en el libro está en <<_removing_objects>>, donde utilizamos brevemente y explicamos el `--ignore-unmatch` al ejecutar `git filter-branch`, el cual simplemente hace que no salga un error cuando el archivo que estamos tratando de eliminar no existe. Esto puede ser útil para fines de scripting.

==== git mv

El comando `git mv` es un comando de conveniencia para mover un archivo y luego ejecutar `git add` en el nuevo archivo y `git rm` en el archivo antiguo.

Sólo mencionamos brevemente este comando en <<_git_mv>>.

==== git clean

El comando `git clean` se utiliza para eliminar archivos no deseados de tu directorio de trabajo. Esto podría incluir la eliminación de artefactos de construcción temporal o la fusión de archivos en conflicto.

Cubrimos muchas de las opciones y escenarios en los que es posible usar el comando clean en <<_git_clean>>.

=== Ramificar y Fusionar

Hay sólo un puñado de comandos que implementan la mayor parte de la funcionalidad de ramificación y fusión en Git.

==== git branch

El comando `git branch` es en realidad una especie de herramienta de gestión de ramas. Puede listar las ramas que tienes, crear una nueva rama, eliminar ramas y cambiar el nombre de las ramas.

La mayor parte de <<_git_branching>> está dedicada al comando `branch` y es utilizado a lo largo de todo el capítulo. En primer lugar, lo introducimos en <<_create_new_branch>> y examinamos la mayor parte de sus otras características (listar y borrar) en <<_branch_management>>.

En <<_tracking_branches>> usamos la opción `git branch -u` para establecer una rama de seguimiento.

Finalmente, examinamos algo de lo que hace en segundo plano en <<_git_refs>>.

==== git checkout

El comando `git checkout` se usa para cambiar de rama y revisar el contenido de tu directorio de trabajo.

En primer lugar, encontramos el comando en <<_switching_branches>> junto con el comando `git branch`.

Vemos cómo usarlo para iniciar el seguimiento de ramas con el indicador `--track` en <<_tracking_branches>>.

Lo usamos para reintroducir los conflictos de archivos con `--conflict=diff3` en <<_checking_out_conflicts>>.

Entramos en más detalle sobre su relación con `git reset` en <<_git_reset>>.

Finalmente, examinamos algún detalle de implementación en <<_the_head>>.

==== git merge

La herramienta `git merge` se utiliza para fusionar uno o más ramas dentro de la rama que tienes activa. A continuación avanzará la rama actual al resultado de la fusión.

El comando `git merge` fue introducido por primera en <<_basic_branching>>. A pesar de que se utiliza en diversos lugares en el libro, hay muy pocas variaciones del comando `merge` -- en general, sólo `git merge <branch>` con el nombre de la rama individual que se desea combinar.

Cubrimos cómo hacer una fusión aplastada (squashed merge) (donde Git fusiona el trabajo, pero finge como si fuera simplemente un nuevo commit sin registrar la historia de la rama que se está fusionando) al final de <<_public_project>>. 

Repasamos mucho sobre el proceso de fusión y dirección, incluyendo el comando `-Xignore-all-whitespace` y el indicador `--abort` para abortar un problema de fusión en <<_advanced_merging>>.

Aprendimos cómo verificar las firmas antes de la fusión si tu proyecto está usando fimas GPG en <<_signing_commits>>.

Finalmente, aprendimos sobre la fusión de subárboles en <<_subtree_merge>>.

==== git mergetool

El comando `git mergetool` simplemente lanza un ayudante de fusión externo en caso de tener problemas con una combinación en Git.

Lo mencionamos rápidamente en <<_basic_merge_conflicts>> y entramos en detalle sobre cómo implementar tu propia herramienta de fusión externa en <<_external_merge_tools>>.

==== git log

The `git log` command is used to show the reachable recorded history of a project from the most recent commit snapshot backwards. By default it will only show the history of the branch you're currently on, but can be given different or even multiple heads or branches from which to traverse. It is also often used to show differences between two or more branches at the commit level.

This command is used in nearly every chapter of the book to demonstrate the history of a project.

We introduce the command and cover it in some depth in <<_viewing_history>>. There we look at the `-p` and `--stat` option to get an idea of what was introduced in each commit and the `--pretty` and `--oneline` options to view the history more concisely, along with some simple date and author filtering options.

In <<_create_new_branch>> we use it with the `--decorate` option to easily visualize where our branch pointers are located and we also use the `--graph` option to see what divergent histories look like.

In <<_private_team>> and <<_commit_ranges>> we cover the `branchA..branchB` syntax to use the `git log` command to see what commits are unique to a branch relative to another branch. In <<_commit_ranges>> we go through this fairly extensively.

In <<_merge_log>> and <<_triple_dot>> we cover using the `branchA...branchB` format and the `--left-right` syntax to see what is in one branch or the other but not in both. In <<_merge_log>> we also look at how to use the `--merge` option to help with merge conflict debugging as well as using the `--cc` option to look at merge commit conflicts in your history.

In <<_git_reflog>> we use the `-g` option to view the Git reflog through this tool instead of doing branch traversal.

In <<_searching>> we look at using the `-S` and `-L` options to do fairly sophisticated searches for something that happened historically in the code such as seeing the history of a function.

In <<_signing_commits>> we see how to use `--show-signature` to add a validation string to each commit in the `git log` output based on if it was validly signed or not.

==== git stash

El comando `git stash` se utiliza para almacenar temporalmente el trabajo no confirmado con el fin de limpiar el directorio de trabajo sin tener que confirmar el trabajo no acabado en una rama.

Básicamente esto es enteramente cubierto en <<_git_stashing>>.

==== git tag

El comando `git tag` se utiliza para dar un marcador permanente a un punto específico en el historial del código fuente. Generalmente esto se utiliza para cosas como las liberaciones (releases).

Este comando se introduce y se trata en detalle en <<_git_tagging>> y lo usamos en la práctica en <<_tagging_releases>>.

También cubrimos cómo crear una etiqueta con firma GPG tag con el indicador `-s` y verificamos uno con el indicador `-v` en <<_signing>>.

=== Compartir y Actualizar Proyectos

No son muy numerosos los comandos de Git que acceden a la red, casi todos los comandos operan sobre la base de datos local. Cuando estas listo para compartir tu trabajo u obtener cambios de otros lugares, hay un puñado de comandos que tienen que ver con los repositorios remotos.

==== git fetch

The `git fetch` command communicates with a remote repository and fetches down all the information that is in that repository that is not in your current one and stores it in your local database.

We first look at this command in <<_fetching_and_pulling>> and we continue to see examples of it use in <<_remote_branches>>.

We also use it in several of the examples in <<_contributing_project>>.

We use it to fetch a single specific reference that is outside of the default space in <<_pr_refs>> and we see how to fetch from a bundle in <<_bundling>>.

We set up highly custom refspecs in order to make `git fetch` do something a little different than the default in <<_refspec>>.

==== git pull

The `git pull` command is basically a combination of the `git fetch` and `git merge` commands, where Git will fetch from the remote you specify and then immediately try to merge it into the branch you're on.

We introduce it quickly in <<_fetching_and_pulling>> and show how to see what it will merge if you run it in <<_inspecting_remote>>.

We also see how to use it to help with rebasing difficulties in <<_rebase_rebase>>.

We show how to use it with a URL to pull in changes in a one-off fashion in <<_checking_out_remotes>>.

Finally, we very quickly mention that you can use the `--verify-signatures` option to it in order to verify that commits you are pulling have been GPG signed in <<_signing_commits>>.

==== git push

The `git push` command is used to communicate with another repository, calculate what your local database has that the remote one does not, and then pushes the difference into the other repository. It requires write access to the other repository and so normally is authenticated somehow.

We first look at the `git push` command in <<_pushing_remotes>>. Here we cover the basics of pushing a branch to a remote repository. In <<_pushing_branches>> we go a little deeper into pushing specific branches and in <<_tracking_branches>> we see how to set up tracking branches to automatically push to. In <<_delete_branches>> we use the `--delete` flag to delete a branch on the server with `git push`.

Throughout <<_contributing_project>> we see several examples of using `git push` to share work on branches through multiple remotes.

We see how to use it to share tags that you have made with the `--tags` option in <<_sharing_tags>>.

In <<_publishing_submodules>> we use the `--recurse-submodules` option to check that all of our submodules work has been published before pushing the superproject, which can be really helpful when using submodules.

In <<_other_client_hooks>> we talk briefly about the `pre-push` hook, which is a script we can setup to run before a push completes to verify that it should be allowed to push.

Finally, in <<_pushing_refspecs>> we look at pushing with a full refspec instead of the general shortcuts that are normally used. This can help you be very specific about what work you wish to share.

==== git remote

The `git remote` command is a management tool for your record of remote repositories. It allows you to save long URLs as short handles, such as ``origin'' so you don't have to type them out all the time. You can have several of these and the `git remote` command is used to add, change and delete them.

This command is covered in detail in <<_remote_repos>>, including listing, adding, removing and renaming them.

It is used in nearly every subsequent chapter in the book too, but always in the standard `git remote add <name> <url>` format.

==== git archive

El comando `git archive` se utiliza para crear un archivo empaquetado de una instantánea específica del proyecto.

Usamos `git archive` para crear un tarball de un proyecto para su compartición en <<_preparing_release>>.

==== git submodule

El comando `git submodule` se utiliza para gestinonar repositorios externos dentro de repositorios normales. 
Esto podría ser por bibliotecas u otros tipos de recursos compartidos. El comando `submodule` tiene varios sub-commandos (`add`, `update`, `sync`, etc) para la gestión de estos recursos.

Este comando es sólo mencionado y cubierto enteramente en <<_git_submodules>>.

=== Inspección y Comparación

==== git show

The `git show` command can show a Git object in a simple and human readable way. Normally you would use this to show the information about a tag or a commit.

We first use it to show annotated tag information in <<_annotated_tags>>.

Later we use it quite a bit in <<_revision_selection>> to show the commits that our various revision selections resolve to.

One of the more interesting things we do with `git show` is in <<_manual_remerge>> to extract specific file contents of various stages during a merge conflict.

==== git shortlog

The `git shortlog` command is used to summarize the output of `git log`. It will take many of the same options that the `git log` command will but instead of listing out all of the commits it will present a summary of the commits grouped by author.

We showed how to use it to create a nice changelog in <<_the_shortlog>>.

==== git describe

The `git describe` command is used to take anything that resolves to a commit and produces a string that is somewhat human-readable and will not change. It's a way to get a description of a commit that is as unambiguous as a commit SHA-1 but more understandable.

We use `git describe` in <<_build_number>> and <<_preparing_release>> to get a string to name our release file after.


=== Depuración

Git tiene un par de comandos que se utilizan para ayudar a depurar un problema en tu código. Esto va desde averiguar donde algo se introdujo a averiguar quién lo introdujo.

==== git bisect

La herramienta `git bisect` es una herramienta de depuración increíblemente útil, utilizada para encontrar qué commit específico fue el primero en introducir un bug o problema, haciendo una búsqueda binaria automática. 

Está completamente cubierto de <<_binary_search>> y sólo se menciona en esa sección.

==== git blame

El comando `git blame` toma nota de las líneas de cualquier archivo con cual commit fue el último en introducir un cambio en cada línea del archivo y qué persona fue autor de ese commit. Esto es muy útil con el fin de encontrar a la persona para pedir más información sobre una sección específica de tu código.

Se cubre en <<_file_annotation>> y sólo se menciona en esa sección.

==== git grep

El comando `git grep` puede ayudarte a encontrar cualquier cadena o expresión regular en cualquiera de los archivos en tu código fuente, incluyendo versiones más antiguas de tu proyecto.

Está cubierto en <<_git_grep>> y sólo se menciona en esa sección.

=== Parcheo

Unos comandos de Git se centran en el concepto de interpretar los commits en términos de los cambios que introducen, concebiendo las series de commit como series de parches. Estos comandos te ayudan a administrar tus ramas de esta manera.

==== git cherry-pick

The `git cherry-pick` command is used to take the change introduced in a single Git commit and try to re-introduce it as a new commit on the branch you're currently on. This can be useful to only take one or two commits from a branch individually rather than merging in the branch which takes all the changes.

Cherry picking is described and demonstrated in <<_rebase_cherry_pick>>.

==== git rebase

The `git rebase` command is basically an automated `cherry-pick`. It determines a series of commits and then cherry-picks them one by one in the same order somewhere else.

Rebasing is covered in detail in <<_rebasing>>, including covering the collaborative issues involved with rebasing branches that are already public.

We use it in practice during an example of splitting your history into two separate repositories in <<_replace>>, using the `--onto` flag as well.

We go through running into a merge conflict during rebasing in <<_rerere>>.

We also use it in an interactive scripting mode with the `-i` option in <<_changing_multiple>>.

==== git revert

The `git revert` command is essentially a reverse `git cherry-pick`. It creates a new commit that applies the exact opposite of the change introduced in the commit you're targeting, essentially undoing or reverting it.

We use this in <<_reverse_commit>> to undo a merge commit.

=== Correo Electrónico

Muchos proyectos Git, incluido el propio Git, se mantienen totalmente a través de listas de correo. Git tiene una serie de herramientas integradas en él que ayudan a hacer más fácil este proceso, desde la generación de parches que pueden enviarse fácilmente por email a aplicar esos parches desde una casilla de correo electrónico.

==== git apply

El comando `git apply` aplica un parche creado con `git diff` o incluso el comando diff de GNU. Es similar a lo que el comando `patch` podría hacer con algunas pequeñas diferencias.

Mostramos a usarlo y las circunstancias en las que puedes hacerlo en <<_patches_from_email>>.

==== git am

El comando `git am` se utiliza para aplicar parches desde una bandeja de entrada de correo electrónico, en concreto una que tenga formato mbox. Esto es útil para recibir parches por correo electrónico y aplicarlos a tu proyecto fácilmente.

Cubrimos el uso y flujo de trabajo en torno a `git am` en <<_git_am>> incluyendo el uso de las opciones `--resolved`, `-i` y `-3`.

Hay también una serie de ganchos (hooks) que se pueden utilizar para ayudar con el flujo de trabajo en torno a `git am` y todos ellos se cubren en <<_email_hooks>>.

También lo utilizamos para aplicar parcheado con formato de cambios de GitHub Pull Request en <<_email_notifications>>.

==== git format-patch

El comando `git format-patch` se utiliza para generar una serie de parches en formato mbox que puedes utilizar para enviar a una lista de correo con el formato correcto.

Examinamos un ejemplo de contribución a un proyecto mediante el uso de la herramienta `git format-patch` en <<_project_over_email>>.

==== git send-email

El comando `git send-email` se utiliza para enviar parches que son generados con `git format-patch` por correo electrónico.

Examinamos un ejemplo de contribución a un proyecto mediante el envío de parches con la herramienta `git send-email` en <<_project_over_email>>.

==== git request-pull

El comando `git request-pull` se utiliza simplemente para generar un cuerpo de mensaje de ejemplo para enviar por correo electrónico a alguien. Si tienes una rama en un servidor público y quieres que alguien sepa cómo integrar esos cambios sin enviar los parches a través de correo electrónico, puedes ejecutar este comando y enviar el resultado a la persona que deseas que rebiba los cambios.

Mostramos como usar `git request-pull` para generar un mensaje pull en <<_public_project>>.

=== Sistemas Externos

Git viene con unos pocos comandos para integrarse con otros sistemas de control de versiones.

==== git svn

El comando `git svn` se utiliza para comunicarnos como cliente con el sistema de control de versiones Subversion. 

Esto significa que puedes usar Git para obtener desde y enviar a un servidor Subversion. 

Este comando es cubierto en profundidad en <<_git_svn>>.

==== git fast-import

Para otros sistemas de control de versiones o importación desde prácticamente cualquier formato, puedes usar `git fast-import` para convertir rápidamente el otro formato a algo que Git pueda registrar fácilmente.

Este comando es cubierto en profundidad en <<_custom_importer>>.

=== Administración

Si estás administrando un repositorio Git o necesitas arreglar algo a lo grande, Git ofrece una serie de comandos de administración para asistirte.

==== git gc

El comando `git gc` ejecuta la ''recogida de basura'' en tu repositorio, eliminando los archivos innecesarios en tu base de datos y empaquetando los archivos restantes en un formato más eficiente.

Este comando se ejecuta normalmente en segundo plano, aunque se puede ejecutar manualmente si se desea. Repasamos algunos ejemplos de esto en <<_git_gc>>.

==== git fsck

El comando `git fsck` se utiliza para comprobar la base de datos interna en busca de problemas o inconsistencias.

Sólo lo utilizamos una vez de forma rápida en <<_data_recovery>> para buscar objetos colgantes.

==== git reflog

El comando `git reflog` examina un registro de donde han estado todas las cabezas de tus ramas mientras trabajas para encontrar commits que puedes haber perdido a través de la reescritura de historias.

Cubrimos este comando principalmente en <<_git_reflog>>, donde mostramos el uso normal y cómo usar `git log -g` para ver la misma información con salida de `git log`.

También repasamos un ejemplo práctico de la recuperación de tal rama perdida en <<_data_recovery>>.

==== git filter-branch

El comando `git filter-branch` se utiliza para reescribir un montón de commits de acuerdo a ciertos patrones, como la eliminación de un archivo de todas partes o el filtrado de todo el repositorio a un solo subdirectorio para sacar un proyecto.

En <<_removing_file_every_commit>> explicamos el comando y exploramos varias opciones diferentes, tales como `--commit-filter`, `--subdirectory-filter` y `--tree-filter`. 

En <<_git_p4>> y <<_git_tfs>> lo usamos para arreglar repositorios externos importados.

=== Comandos de Fontanería

También había un buen número de comandos de fontanería de bajo nivel que nos encontramos en el libro.

El primero que encontramos es `ls-remote` en <<_pr_refs>>, que usamos para mirar las referencias en bruto en el servidor.

Usamos `ls-files` en <<_manual_remerge>>, <<_rerere>> y <<_the_index>> para echar un vistazo más en bruto a la apariencia del área de preparación.

También mencionamos `rev-parse` en <<_branch_references>> para tomar casi cualquier cadena y convertirla en un objeto SHA1.

Sin embargo, la mayoría de los comandos de bajo nivel de fontanería que cubrimos están en <<_git_internals>>, que es más o menos en lo que el capítulo se centra. Tratamos de evitar el uso de ellos en la mayor parte del resto del libro.
