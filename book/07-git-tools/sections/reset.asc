[[_git_reset]]
=== Reset Demystified

Before moving on to more specialized tools, let's talk about `reset` and `checkout`.
These commands are two of the most confusing parts of Git when you first encounter them.
They do so many things, that it seems hopeless to actually understand them and employ them properly.
For this, we recommend a simple metaphor.

==== The Three Trees

An easier way to think about `reset` and `checkout` is through the mental frame of Git being a content manager of three different trees.
By ``tree'' here we really mean ``collection of files'', not specifically the data structure.
(There are a few cases where the index doesn't exactly act like a tree, but for our purposes it is easier to think about it this way for now.)

Git como un sistema administra y manipula tres árboles en su operación normal:

[cols="1,2",options="header"]
|================================
| Arbol              | Rol
| HEAD        | Última instantanea aislada, próximo formulario
| Index             | Proposed next commit snapshot
| Directorio de trabajo | Caja de arena
|================================

===== HEAD

HEAD es el puntero a la referencia actual de la rama, que es a su vez un puntero para el último aislamiento realizado en esa rama. 
Eso significa que HEAD será el formulario del siguiente aislamiento que se cree.
Es generalmente más simple el pensar de HEAD como una instantánea de *tu último aislamiento*.

De hecho, es bastante fácil el ver como esa instantánea luce. 
Aquí está un ejemplo de la obtención del directorio actual y la suma de los chequeos SHA-1 para cada archivo en la instantánea de HEAD:

[source,console]
----
$ git cat-file -p HEAD
tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf
author Scott Chacon  1301511835 -0700
committer Scott Chacon  1301511835 -0700

initial commit

$ git ls-tree -r HEAD
100644 blob a906cb2a4a904a152...   README
100644 blob 8f94139338f9404f2...   Rakefile
040000 tree 99f1a6d12cb4b6f19...   lib
----

Los comandos `cat-file` y `ls-tree` son comandos de ``tuberías'' que son usados para cosas de bajo nivel y que no son usadas en el trabajo del día a día, pero nos ayudan a ver lo que está pasando aquí.

[[_the_index]]
===== El índice

El índice es tu *siguiente aislamiento propuesto*. Tambien nos hemos estado refiriendo a este concepto como el ``staging area' as this is what Git looks at when you run `git commit`.

+Git rellena este índice con una lista de todos los contenidos de los archivos que fueron previamente chequeados en nuestro directorio de trabajo y como lucían cuando fueron chequeados originalmente.
+Entonces remplazas algunos de esos archivos con nuevas versiones de los mismos, y `git commit` los convierte en el árbol para un nuevo aislamiento. 

[source,console]
----
$ git ls-files -s
100644 a906cb2a4a904a152e80877d4088654daad0c859 0	README
100644 8f94139338f9404f26296befa88755fc2598c289 0	Rakefile
100644 47c6340d6459e05787f644c2447d2595f5d3a54b 0	lib/simplegit.rb
----

De nuevo, aquí estamos usando `ls-files`, lo que es más un comando de detrás de escena que muestra como tu índice se ve actualmente.

El índice no es técnicamente una estructura de árbol - es implementada como una patente aplanada - pero para nuestros propósitos esta analogía es bastante acercada.

===== El directorio de trabajo

Finalmente, tienes tu directorio de trabajo.
Los otros dos árboles depositas sus contenidos en una forma eficiente pero inconveniente, dentro de la carpeta `.git`.
El directorio de trabajo los desempaca en archivos, lo que hace más facil para ti el editarlos.
Piensa del directorio de trabajo como una *caja de arena*, donde puedes intentar hacer algunos cambios antes de asignarlos a tu area de montaje (índice) y luego a tu historial.

[source,console]
----
$ tree
.
├── README
├── Rakefile
└── lib
    └── simplegit.rb

1 directory, 3 files
----

==== El flujo de trabajo

El principal propósito de Git es el registrar instantáneas de tu proyecto en mejores estados sucesivos, mediante la manipulación de estos tres árboles.

image::images/reset-workflow.png[]

Visualicemos este proceso: digamos que tu entras a un nuevo directorio con un solo archivo en él.
Lo llamaremos el *v1* del archivo, y luego lo indicaremos con azul.
Ahora corremos `git init`, lo que creará un repositorio Git con una referencia de CABEZA que señalará hacia una rama aun no creada (`master` aun no existe).

image::images/reset-ex1.png[]

En este punto, sólo el Directorio de Trabajo tiene algun contenido.

Ahora queremos asignar este archivo, así que usamos `git add` para tomar el contenido al Directorio de Trabajo y copiarlo al Índice.

image::images/reset-ex2.png[]

Ahora corremos `git commit`, que tomará los contenidos el Índice y los guardará como una instantánea permanente, creará un objeto asignado que señalará a esa instantánea y actualizará `master` para señalar esa asignación.

image::images/reset-ex3.png[]

Si corremos `git status`, no veremos cambios, ya que los tres árboles son el mismo.

Ahora queremos hacer un cambio a ese archivo y asignarlo.
Haremos el mismo proceso; primero cambiaremos el archivo en nuestro directorio de trabajo.
Llamemos esto el *v2* del archivo, y lo indicaremos en rojo.

image::images/reset-ex4.png[]

If we run `git status` right now, we'll see the file in red as ``Changes not staged for commit,'' because that entry differs between the Index and the Working Directory.
Next we run `git add` on it to stage it into our Index.

image::images/reset-ex5.png[]

En este punto si corremos `git status` veremos el archivo en verde
under ``Changes to be committed'' because the Index and HEAD differ – that is, our proposed next commit is now different from our last commit.
Finally, we run `git commit` para finalizar la asignación.

image::images/reset-ex6.png[]

Ahora `git status` no nos dará respuesta, porque todos los árboles son el mismo de nuevo.

El cambiar de ramas o clonar se hace a través de un proceso similar.
Cuando revisas una rama, cambia la *HEAD* para señalar a la referencia de la nueva rama, rellena tu *Índice* con la instantánea de esa asignación, entonces copia los contenidos del *Índice* dentro de tu *Directorio de Trabajo*.

==== El rol del reseteo

El comando `reset` tiene más sentido cuando se le mira en este contexto.

Para los propósitos de estos ejemplos, digamos que hemos modificado `file.txt` de nuevo y asignado por una tercera vez. Así que nuestro historial lucirá así:

image::images/reset-start.png[]

Ahora vayamos a lo que `reset` hace cuando lo llamas. Directamente manipula estos tres árboles de una manera simple y predecible.
Ejecuta hasta tres operaciones básicas.

===== Paso 1: mueve HEAD

La primera cosa que hará `reset` es mover hacia donde señala HEAD.
Esto no es lo mismo que cambiar HEAD (que es lo que `checkout` hace); `reset` mueve la rama a la que HEAD está apuntando.
Esto significa que si HEAD está fija en la rama `master` (i.e. estás en la rama `master` ), el correr `git reset 9e5e64a` hara que ahora `master` señale hacia `9e5e64a`.

image::images/reset-soft.png[]

No importa que forma de `reset` con una asignación recurras, esta es la primera cosa que siempre tratará de hacer.
Con `reset --soft`, Simplemente se detendrá ahí

Ahora mira otra vez ese diagrama y date cuenta de lo que pasó: eso simplemente deshizo el último comando `git commit`. 
Cuando corres `git commit`, Git crea una nueva asignación y mueve la rama hacia la que apunta HEAD hacia la misma.
Cuando tú `reset` de nuevo a`HEAD~` (el filial de HEAD), estás moviendo la rama donde ya estaba, sin cambiar el Índice o el Directorio de Trabajo.
Ahora podrías actualizar el Índice y correr `git commit` de nuevo para lograr lo que `git commit --amend` habría hecho (ver <<_git_amend>>).

===== Paso 2: Actualizando el índice (--mixed)

Tenga en cuenta que si ejecuta `git status` ahora verá en verde la diferencia entre el Índice y lo que el nuevo HEAD es.

Lo siguiente que `reset` hará es actualizar el Índice con los contenidos de cualquier instantánea que HEAD señale ahora.

image::images/reset-mixed.png[]

Si especifica la opción `--mixed`, `reset` se detendrá en este punto.
Este también es el por defecto, por lo que si no especifica ninguna opción (solo `git reset HEAD~` en este caso), aquí es donde el comando se detendrá.

Ahora tómese otro segundo para mirar ese diagrama y darse cuenta de lo que sucedió: todavía deshizo su último `commit`, pero también hizo _unstaged_ de todo.
Retrocedió a antes de ejecutar todos sus comandos `git add` y `git commit`.
=======

===== Paso 3: Actualizar el Directorio de Trabajo (--hard)

Lo tercero que `reset` hará es hacer que el Directorio de Trabajo se parezca al Índice.
Si usa la opción `--hard`, continuará en esta etapa.

image::images/reset-hard.png[]

Entonces, pensemos en lo que acaba de pasar.
Deshizo su último commit, los comandos `git add` y `git commit`, **y** todo el trabajo que hizo en su directorio de trabajo.

Es importante tener en cuenta que este indicador (`--hard`) es la única manera de hacer que el comando `reset` sea peligroso, y uno de los pocos casos en que Git realmente destruirá los datos.
Cualquier otra invocación de `reset` puede deshacerse fácilmente, pero la opción `--hard` no puede, ya que sobrescribe forzosamente los archivos en el Directorio de Trabajo.
En este caso particular, todavía tenemos la versión *v3* de nuestro archivo en una commit en nuestro DB de Git, y podríamos recuperarla mirando nuestro `reflog`, pero si no le hubiéramos hecho commit, Git hubiese sobrescrito el archivo y sería irrecuperable.

===== Resumen

El comando `reset` sobrescribe estos tres árboles en un orden específico, deteniéndose cuando ustéd le dice:

1. Mueva los puntos HEAD de la rama a _(deténgase aquí si `--soft`)_
2. Haga que el Índice se vea como HEAD _(deténgase aquí a menos que `--hard`)_
3. Haga que el Directorio de Trabajo se vea como el Índice

==== Reiniciar Con una Ruta

Eso cubre el comportamiento de `reset` en su forma básica, pero también puede proporcionarle una ruta para actuar.
Si especifica una ruta, `reset` omitirá el paso 1 y limitará el resto de sus acciones a un archivo o conjunto específico de archivos.
Esto realmente tiene sentido – HEAD es solo un puntero, y no se puede apuntar a una parte de una commit y parte de otra.
Pero el índice y el Directorio de Trabajo _pueden_ actualizarse parcialmente, por lo que el reinicio continúa con los pasos 2 y 3.

Entonces, supongamos que ejecutamos `git reset file.txt`.
Este formulario (ya que no especificó un commit SHA-1 o una rama, y no especificó `--soft` o `--hard`) es una abreviatura de `git reset --mixed HEAD file.txt`, la cual hará:

1. Mueva los puntos HEAD de la rama a _(omitido)_
2. Haga que el Índice se vea como HEAD _(deténgase aquí)_

Por lo tanto, básicamente solo copia `archivo.txt` de HEAD al Índice.

image::images/reset-path1.png[]

Esto tiene el efecto práctico de hacer _unstaging_ al archivo.
Si miramos el diagrama para ese comando y pensamos en lo que hace `git add`, son exactamente opuestos.

image::images/reset-path2.png[]

Esta es la razón por la cual el resultado del comando `git status` sugiere que ejecute esto para descentralizar un archivo.
(Consulte <<_unstaging>> para más sobre esto).

Igualmente podríamos no permitir que Git suponga que queríamos ``extraer los datos de HEAD'' especificando una commit específica para extraer esa versión del archivo.
Simplemente ejecutaríamos algo como `git reset eb43bf file.txt`.

image::images/reset-path3.png[]

Esto efectivamente hace lo mismo que si hubiéramos revertido el contenido del archivo a *v1* en el Directorio de Trabajo, ejecutáramos `git add` en él, y luego lo revertimos a *v3* nuevamente (sin tener que ir a través de todos esos pasos)
Si ejecutamos `git commit` ahora, registrará un cambio que revierte ese archivo de vuelta a *v1*, aunque nunca más lo volvimos a tener en nuestro Directorio de Trabajo.

También es interesante observar que, como `git add`, el comando `reset` aceptará una opción `--patch` para hacer unstage del contenido en una base hunk-by-hunk.
Por lo tanto, puede hacer unstage o revertir el contenido de forma selectiva.

==== Aplastando

Veamos cómo hacer algo interesante con este poder recién descubierto – aplastando commits.

Supongamos que tiene una serie de confirmaciones con mensajes como ``oops.'', ``WIP'' y ``se olvidó de este archivo''.
Puedes usar `reset` para aplastarlos rápida y fácilmente en una sola confirmación que lo hace ver realmente inteligente.
(<<_aplastando>> muestra otra forma de hacerlo, pero en este ejemplo es más simple usar `reset`.)

Supongamos que tiene un proyecto en el que la primera commit tiene un archivo, la segunda commit agregó un nuevo archivo y cambió la primera, y la tercera commit cambió el primer archivo otra vez.
La segunda commit fué un trabajo en progreso y quiere aplastarlo.

image::images/reset-squash-r1.png[]

Puede ejecutar `git reset --soft HEAD~2` para mover la rama HEAD a una commit anterior (la primera commit que desea mantener):

image::images/reset-squash-r2.png[]

Y luego simplemente ejecute `git commit` nuevamente:

image::images/reset-squash-r3.png[]

Ahora puede ver que su historial alcanzable, la historia que empujaría, ahora parece que tuvo una commit con `archivo-a.txt` v1, luego un segundo que ambos modificaron `archivo-a.txt` a v3 y agregaron `archivo-b.txt`. La commit con la versión v2 del archivo ya no está en el historial.


==== Echale Un vistazo

Finalmente, puede preguntarse cuál es la diferencia entre `checkout` y `reset`.
Al igual que `reset`, `checkout` manipula los tres árboles, y es un poco diferente dependiendo de si le da al comando una ruta de archivo o no.

===== Sin Rutas

Ejecutar `git checkout [branch]` es bastante similar a ejecutar `git reset --hard [branch]` porque actualiza los tres árboles para que se vea como `[branch]`, pero hay dos diferencias importantes.

Primero, a diferencia de `reset --hard`, `checkout` está directorio-de-trabajo seguro; Verificará para asegurarse de que no está volando los archivos que tienen cambios en ellos.
En realidad, es un poco más inteligente que eso – intenta hacer una fusión trivial en el Directorio de Trabajo, por lo que todos los archivos que _no haya_ cambiado serán actualizados.
`reset --hard`, por otro lado, simplemente reemplazará todo en general sin verificar.

La segunda diferencia importante es cómo actualiza HEAD.
Donde `reset` moverá la rama a la que HEAD apunta, `checkout` moverá HEAD para señalar otra rama.

Por ejemplo, digamos que tenemos las ramas `master` y `develop` que apuntan a diferentes commits, y actualmente estamos en `develop` (así que HEAD lo señala).
Si ejecutamos `git reset master`, `develop` ahora apuntará a la misma commit que `master`.
Si en cambio ejecutamos `git checkout master`, `develop` no se mueve, HEAD sí lo hace.
HEAD ahora apuntará a `master`.

Entonces, en ambos casos estamos moviendo HEAD para apuntar a la commit A, pero _cómo_ lo hacemos es muy diferente.
`reset` moverá los puntos HEAD de la rama a, `checkout` mueve el mismo HEAD.

image::images/reset-checkout.png[]

===== Con Rutas

La otra forma de ejecutar `checkout` es con una ruta de archivo, que, como `reset`, no mueva HEAD.
Es como `git reset [branch] file` en que actualiza el índice con ese archivo en esa commit, pero también sobrescribe el archivo en el directorio de trabajo.
Sería exactamente como `git reset --hard [branch] file` (si `reset` le permitiera ejecutar eso) - no está directorio-de-trabajo seguro, y no mueve a HEAD.

Además, al igual que `git reset` y `git add`, `checkout` aceptará una opción `--patch` para permitirle revertir selectivamente el contenido del archivo sobre una base hunk-by-hunk.

==== Resumen

Esperemos que ahora entienda y se sienta más cómodo con el comando `reset`, pero probablemente todavía esté un poco confundido acerca de cómo exactamente difiere de `checkout` y posiblemente no pueda recordar todas las reglas de las diferentes invocaciones.

Aquí hay una hoja de trucos para cuales comandos afectan a cuales árboles.
La columna ``HEAD'' lee ``REF'' si ese comando mueve la referencia (rama) a la que HEAD apunta, y ``HEAD'' si mueve al mismo HEAD.
Esta función calculará la ciudad y el país del visitante desde la dirección IP. Para activar esta función, debes descargar la base de datos GeoIP y configurar la clave de la API de Google. Por favor, vea "Más información"

[options="header", cols="3,1,1,1,1"]
|================================
| | HEAD | Índice | Dirtrabajo | DT Seguro?
| *Nivl de la Commit* | | | |
| `reset --soft [commit]` | REF | NO | NO | SI
| `reset [commit]` | REF | SI | NO | SI
| `reset --hard [commit]` | REF | SI | SI | *NO*
| `checkout [commit]` | HEAD | SI | SI | SI
| *Nivel de Archivo* | | | |
| `reset (commit) [file]` | NO | SI | NO | SI
| `checkout (commit) [file]` | NO | SI | SI | *NO*
|================================
