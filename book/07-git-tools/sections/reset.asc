[[_git_reset]]
=== Reset Demystified

Before moving on to more specialized tools, let's talk about `reset` and `checkout`.
These commands are two of the most confusing parts of Git when you first encounter them.
They do so many things, that it seems hopeless to actually understand them and employ them properly.
For this, we recommend a simple metaphor.

==== The Three Trees

An easier way to think about `reset` and `checkout` is through the mental frame of Git being a content manager of three different trees.
By ``tree'' here we really mean ``collection of files'', not specifically the data structure.
(There are a few cases where the index doesn't exactly act like a tree, but for our purposes it is easier to think about it this way for now.)

Git as a system manages and manipulates three trees in its normal operation:

[cols="1,2",options="header"]
|================================
| Tree              | Role
| HEAD              | Last commit snapshot, next parent
| Index             | Proposed next commit snapshot
| Working Directory | Sandbox
|================================

===== The HEAD

HEAD is the pointer to the current branch reference, which is in turn a pointer to the last commit made on that branch.
That means HEAD will be the parent of the next commit that is created.
It's generally simplest to think of HEAD as the snapshot of *your last commit*.

In fact, it's pretty easy to see what that snapshot looks like.
Here is an example of getting the actual directory listing and SHA-1 checksums for each file in the HEAD snapshot:

[source,console]
----
$ git cat-file -p HEAD
tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf
author Scott Chacon  1301511835 -0700
committer Scott Chacon  1301511835 -0700

initial commit

$ git ls-tree -r HEAD
100644 blob a906cb2a4a904a152...   README
100644 blob 8f94139338f9404f2...   Rakefile
040000 tree 99f1a6d12cb4b6f19...   lib
----

The `cat-file` and `ls-tree` commands are ``plumbing'' commands that are used for lower level things and not really used in day-to-day work, but they help us see what's going on here.

[[_the_index]]
===== The Index

The Index is your *proposed next commit*. We've also been referring to this concept as Git's ``Staging Area'' as this is what Git looks at when you run `git commit`.

Git populates this index with a list of all the file contents that were last checked out into your working directory and what they looked like when they were originally checked out.
You then replace some of those files with new versions of them, and `git commit` converts that into the tree for a new commit.

[source,console]
----
$ git ls-files -s
100644 a906cb2a4a904a152e80877d4088654daad0c859 0	README
100644 8f94139338f9404f26296befa88755fc2598c289 0	Rakefile
100644 47c6340d6459e05787f644c2447d2595f5d3a54b 0	lib/simplegit.rb
----

Again, here we're using `ls-files`, which is more of a behind the scenes command that shows you what your index currently looks like.

The index is not technically a tree structure – it's actually implemented as a flattened manifest – but for our purposes it's close enough.

===== The Working Directory

Finally, you have your working directory.
The other two trees store their content in an efficient but inconvenient manner, inside the `.git` folder.
The Working Directory unpacks them into actual files, which makes it much easier for you to edit them.
Think of the Working Directory as a *sandbox*, where you can try changes out before committing them to your staging area (index) and then to history.

[source,console]
----
$ tree
.
├── README
├── Rakefile
└── lib
    └── simplegit.rb

1 directory, 3 files
----

==== The Workflow

Git's main purpose is to record snapshots of your project in successively better states, by manipulating these three trees.

image::images/reset-workflow.png[]

Let's visualize this process: say you go into a new directory with a single file in it.
We'll call this *v1* of the file, and we'll indicate it in blue.
Now we run `git init`, which will create a Git repository with a HEAD reference which points to an unborn branch (`master` doesn't exist yet).

image::images/reset-ex1.png[]

At this point, only the Working Directory tree has any content.

Now we want to commit this file, so we use `git add` to take content in the Working Directory and copy it to the Index.

image::images/reset-ex2.png[]

Then we run `git commit`, which takes the contents of the Index and saves it as a permanent snapshot, creates a commit object which points to that snapshot, and updates `master` to point to that commit.

image::images/reset-ex3.png[]

If we run `git status`, we'll see no changes, because all three trees are the same.

Now we want to make a change to that file and commit it.
We'll go through the same process; first we change the file in our working directory.
Let's call this *v2* of the file, and indicate it in red.

image::images/reset-ex4.png[]

If we run `git status` right now, we'll see the file in red as ``Changes not staged for commit,'' because that entry differs between the Index and the Working Directory.
Next we run `git add` on it to stage it into our Index.

image::images/reset-ex5.png[]

At this point if we run `git status` we will see the file in green
under ``Changes to be committed'' because the Index and HEAD differ – that is, our proposed next commit is now different from our last commit.
Finally, we run `git commit` to finalize the commit.

image::images/reset-ex6.png[]

Now `git status` will give us no output, because all three trees are the same again.

Switching branches or cloning goes through a similar process.
When you checkout a branch, it changes *HEAD* to point to the new branch ref, populates your *Index* with the snapshot of that commit, then copies the contents of the *Index* into your *Working Directory*.

==== The Role of Reset

The `reset` command makes more sense when viewed in this context.

For the purposes of these examples, let's say that we've modified `file.txt` again and committed it a third time. So now our history looks like this:

image::images/reset-start.png[]

Let's now walk through exactly what `reset` does when you call it. It directly manipulates these three trees in a simple and predictable way.
It does up to three basic operations.

===== Step 1: Move HEAD

The first thing `reset` will do is move what HEAD points to.
This isn't the same as changing HEAD itself (which is what `checkout` does); `reset` moves the branch that HEAD is pointing to.
This means if HEAD is set to the `master` branch (i.e. you're currently on the `master` branch), running `git reset 9e5e64a` will start by making `master` point to `9e5e64a`.

image::images/reset-soft.png[]

No matter what form of `reset` with a commit you invoke, this is the first thing it will always try to do.
With `reset --soft`, it will simply stop there.

Now take a second to look at that diagram and realize what happened: it essentially undid the last `git commit` command.
When you run `git commit`, Git creates a new commit and moves the branch that HEAD points to up to it.
When you `reset` back to `HEAD~` (the parent of HEAD), you are moving the branch back to where it was, without changing the Index or Working Directory.
You could now update the Index and run `git commit` again to accomplish what `git commit --amend` would have done (see <<_git_amend>>).

===== Paso 2: Actualizando el índice (--mixed)

Tenga en cuenta que si ejecuta `git status` ahora verá en verde la diferencia entre el Índice y lo que el nuevo HEAD es.

Lo siguiente que `reset` hará es actualizar el Índice con los contenidos de cualquier instantánea que HEAD señale ahora.

image::images/reset-mixed.png[]

Si especifica la opción `--mixed`, `reset` se detendrá en este punto.
Este también es el por defecto, por lo que si no especifica ninguna opción (solo `git reset HEAD~` en este caso), aquí es donde el comando se detendrá.

Ahora tómese otro segundo para mirar ese diagrama y darse cuenta de lo que sucedió: todavía deshizo su último `commit`, pero también hizo _unstaged_ de todo.
Retrocedió a antes de ejecutar todos sus comandos `git add` y `git commit`.

===== Paso 3: Actualizar el Directorio de Trabajo (--hard)

Lo tercero que `reset` hará es hacer que el Directorio de Trabajo se parezca al Índice.
Si usa la opción `--hard`, continuará en esta etapa.

image::images/reset-hard.png[]

Entonces, pensemos en lo que acaba de pasar.
Deshizo su último commit, los comandos `git add` y `git commit`, **y** todo el trabajo que hizo en su directorio de trabajo.

Es importante tener en cuenta que este indicador (`--hard`) es la única manera de hacer que el comando `reset` sea peligroso, y uno de los pocos casos en que Git realmente destruirá los datos.
Cualquier otra invocación de `reset` puede deshacerse fácilmente, pero la opción `--hard` no puede, ya que sobrescribe forzosamente los archivos en el Directorio de Trabajo.
En este caso particular, todavía tenemos la versión *v3* de nuestro archivo en una commit en nuestro DB de Git, y podríamos recuperarla mirando nuestro `reflog`, pero si no le hubiéramos hecho commit, Git hubiese sobrescrito el archivo y sería irrecuperable.

===== Resumen

El comando `reset` sobrescribe estos tres árboles en un orden específico, deteniéndose cuando ustéd le dice:

1. Mueva los puntos HEAD de la rama a _(deténgase aquí si `--soft`)_
2. Haga que el Índice se vea como HEAD _(deténgase aquí a menos que `--hard`)_
3. Haga que el Directorio de Trabajo se vea como el Índice

==== Reiniciar Con una Ruta

Eso cubre el comportamiento de `reset` en su forma básica, pero también puede proporcionarle una ruta para actuar.
Si especifica una ruta, `reset` omitirá el paso 1 y limitará el resto de sus acciones a un archivo o conjunto específico de archivos.
Esto realmente tiene sentido – HEAD es solo un puntero, y no se puede apuntar a una parte de una commit y parte de otra.
Pero el índice y el Directorio de Trabajo _pueden_ actualizarse parcialmente, por lo que el reinicio continúa con los pasos 2 y 3.

Entonces, supongamos que ejecutamos `git reset file.txt`.
Este formulario (ya que no especificó un commit SHA-1 o una rama, y no especificó `--soft` o `--hard`) es una abreviatura de `git reset --mixed HEAD file.txt`, la cual hará:

1. Mueva los puntos HEAD de la rama a _(omitido)_
2. Haga que el Índice se vea como HEAD _(deténgase aquí)_

Por lo tanto, básicamente solo copia `archivo.txt` de HEAD al Índice.

image::images/reset-path1.png[]

Esto tiene el efecto práctico de hacer _unstaging_ al archivo.
Si miramos el diagrama para ese comando y pensamos en lo que hace `git add`, son exactamente opuestos.

image::images/reset-path2.png[]

Esta es la razón por la cual el resultado del comando `git status` sugiere que ejecute esto para descentralizar un archivo.
(Consulte <<_unstaging>> para más sobre esto).

Igualmente podríamos no permitir que Git suponga que queríamos ``extraer los datos de HEAD'' especificando una commit específica para extraer esa versión del archivo.
Simplemente ejecutaríamos algo como `git reset eb43bf file.txt`.

image::images/reset-path3.png[]

Esto efectivamente hace lo mismo que si hubiéramos revertido el contenido del archivo a *v1* en el Directorio de Trabajo, ejecutáramos `git add` en él, y luego lo revertimos a *v3* nuevamente (sin tener que ir a través de todos esos pasos)
Si ejecutamos `git commit` ahora, registrará un cambio que revierte ese archivo de vuelta a *v1*, aunque nunca más lo volvimos a tener en nuestro Directorio de Trabajo.

También es interesante observar que, como `git add`, el comando `reset` aceptará una opción `--patch` para hacer unstage del contenido en una base hunk-by-hunk.
Por lo tanto, puede hacer unstage o revertir el contenido de forma selectiva.

==== Aplastando

Veamos cómo hacer algo interesante con este poder recién descubierto – aplastando commits.

Supongamos que tiene una serie de confirmaciones con mensajes como ``oops.'', ``WIP'' y ``se olvidó de este archivo''.
Puedes usar `reset` para aplastarlos rápida y fácilmente en una sola confirmación que lo hace ver realmente inteligente.
(<<_aplastando>> muestra otra forma de hacerlo, pero en este ejemplo es más simple usar `reset`.)

Supongamos que tiene un proyecto en el que la primera commit tiene un archivo, la segunda commit agregó un nuevo archivo y cambió la primera, y la tercera commit cambió el primer archivo otra vez.
La segunda commit fué un trabajo en progreso y quiere aplastarlo.

image::images/reset-squash-r1.png[]

Puede ejecutar `git reset --soft HEAD~2` para mover la rama HEAD a una commit anterior (la primera commit que desea mantener):

image::images/reset-squash-r2.png[]

Y luego simplemente ejecute `git commit` nuevamente:

image::images/reset-squash-r3.png[]

Ahora puede ver que su historial alcanzable, la historia que empujaría, ahora parece que tuvo una commit con `archivo-a.txt` v1, luego un segundo que ambos modificaron `archivo-a.txt` a v3 y agregaron `archivo-b.txt`. La commit con la versión v2 del archivo ya no está en el historial.


==== Echale Un vistazo

Finalmente, puede preguntarse cuál es la diferencia entre `checkout` y `reset`.
Al igual que `reset`, `checkout` manipula los tres árboles, y es un poco diferente dependiendo de si le da al comando una ruta de archivo o no.

===== Sin Rutas

Ejecutar `git checkout [branch]` es bastante similar a ejecutar `git reset --hard [branch]` porque actualiza los tres árboles para que se vea como `[branch]`, pero hay dos diferencias importantes.

Primero, a diferencia de `reset --hard`, `checkout` está directorio-de-trabajo seguro; Verificará para asegurarse de que no está volando los archivos que tienen cambios en ellos.
En realidad, es un poco más inteligente que eso – intenta hacer una fusión trivial en el Directorio de Trabajo, por lo que todos los archivos que _no haya_ cambiado serán actualizados.
`reset --hard`, por otro lado, simplemente reemplazará todo en general sin verificar.

La segunda diferencia importante es cómo actualiza HEAD.
Donde `reset` moverá la rama a la que HEAD apunta, `checkout` moverá HEAD para señalar otra rama.

Por ejemplo, digamos que tenemos las ramas `master` y `develop` que apuntan a diferentes commits, y actualmente estamos en `develop` (así que HEAD lo señala).
Si ejecutamos `git reset master`, `develop` ahora apuntará a la misma commit que `master`.
Si en cambio ejecutamos `git checkout master`, `develop` no se mueve, HEAD sí lo hace.
HEAD ahora apuntará a `master`.

Entonces, en ambos casos estamos moviendo HEAD para apuntar a la commit A, pero _cómo_ lo hacemos es muy diferente.
`reset` moverá los puntos HEAD de la rama a, `checkout` mueve el mismo HEAD.

image::images/reset-checkout.png[]

===== Con Rutas

La otra forma de ejecutar `checkout` es con una ruta de archivo, que, como `reset`, no mueva HEAD.
Es como `git reset [branch] file` en que actualiza el índice con ese archivo en esa commit, pero también sobrescribe el archivo en el directorio de trabajo.
Sería exactamente como `git reset --hard [branch] file` (si `reset` le permitiera ejecutar eso) - no está directorio-de-trabajo seguro, y no mueve a HEAD.

Además, al igual que `git reset` y `git add`, `checkout` aceptará una opción `--patch` para permitirle revertir selectivamente el contenido del archivo sobre una base hunk-by-hunk.

==== Resumen

Esperemos que ahora entienda y se sienta más cómodo con el comando `reset`, pero probablemente todavía esté un poco confundido acerca de cómo exactamente difiere de `checkout` y posiblemente no pueda recordar todas las reglas de las diferentes invocaciones.

Aquí hay una hoja de trucos para cuales comandos afectan a cuales árboles.
La columna ``HEAD'' lee ``REF'' si ese comando mueve la referencia (rama) a la que HEAD apunta, y ``HEAD'' si mueve al mismo HEAD.
Esta función calculará la ciudad y el país del visitante desde la dirección IP. Para activar esta función, debes descargar la base de datos GeoIP y configurar la clave de la API de Google. Por favor, vea "Más información"

[options="header", cols="3,1,1,1,1"]
|================================
| | HEAD | Índice | Dirtrabajo | DT Seguro?
| *Nivl de la Commit* | | | |
| `reset --soft [commit]` | REF | NO | NO | SI
| `reset [commit]` | REF | SI | NO | SI
| `reset --hard [commit]` | REF | SI | SI | *NO*
| `checkout [commit]` | HEAD | SI | SI | SI
| *Nivel de Archivo* | | | |
| `reset (commit) [file]` | NO | SI | NO | SI
| `checkout (commit) [file]` | NO | SI | SI | *NO*
|================================
