[[_advanced_merging]]
=== Advanced Merging

Merging in Git is typically fairly easy. Since Git makes it easy to merge another branch multiple times, it means that you can have a very long lived branch but you can keep it up to date as you go, solving small conflicts often, rather than be surprised by one enormous conflict at the end of the series.

However, sometimes tricky conflicts do occur. Unlike some other version control systems, Git does not try to be overly clever about merge conflict resolution. Git's philosophy is to be smart about determining when a merge resolution is unambiguous, but if there is a conflict, it does not try to be clever about automatically resolving it. Therefore, if you wait too long to merge two branches that diverge quickly, you can run into some issues.

In this section, we'll go over what some of those issues might be and what tools Git gives you to help handle these more tricky situations. We'll also cover some of the different, non-standard types of merges you can do, as well as see how to back out of merges that you've done.

==== Merge Conflicts

While we covered some basics on resolving merge conflicts in <<_basic_merge_conflicts>>, for more complex conflicts, Git provides a few tools to help you figure out what's going on and how to better deal with the conflict.

First of all, if at all possible, try to make sure your working directory is clean before doing a merge that may have conflicts. If you have work in progress, either commit it to a temporary branch or stash it. This makes it so that you can undo *anything* you try here. If you have unsaved changes in your working directory when you try a merge, some of these tips may help you lose that work.

Let's walk through a very simple example. We have a super simple Ruby file that prints 'hello world'.

[source,ruby]
----
#! /usr/bin/env ruby

def hello
  puts 'hello world'
end

hello()
----

In our repository, we create a new branch named `whitespace` and proceed to change all the Unix line endings to DOS line endings, essentially changing every line of the file, but just with whitespace. Then we change the line ``hello world'' to ``hello mundo''.

[source,console]
----
$ git checkout -b whitespace
Switched to a new branch 'whitespace'

$ unix2dos hello.rb
unix2dos: converting file hello.rb to DOS format ...
$ git commit -am 'converted hello.rb to DOS'
[whitespace 3270f76] converted hello.rb to DOS
 1 file changed, 7 insertions(+), 7 deletions(-)

$ vim hello.rb
$ git diff -w
diff --git a/hello.rb b/hello.rb
index ac51efd..e85207e 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,7 +1,7 @@
 #! /usr/bin/env ruby

 def hello
-  puts 'hello world'
+  puts 'hello mundo'^M
 end

 hello()

$ git commit -am 'hello mundo change'
[whitespace 6d338d2] hello mundo change
 1 file changed, 1 insertion(+), 1 deletion(-)
----

Now we switch back to our `master` branch and add some documentation for the function.

[source,console]
----
$ git checkout master
Switched to branch 'master'

$ vim hello.rb
$ git diff
diff --git a/hello.rb b/hello.rb
index ac51efd..36c06c8 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,5 +1,6 @@
 #! /usr/bin/env ruby

+# prints out a greeting
 def hello
   puts 'hello world'
 end

$ git commit -am 'document the function'
[master bec6336] document the function
 1 file changed, 1 insertion(+)
----

Now we try to merge in our `whitespace` branch and we'll get conflicts because of the whitespace changes.

[source,console]
----
$ git merge whitespace
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Automatic merge failed; fix conflicts and then commit the result.
----

[[_abort_merge]]
===== Aborting a Merge

We now have a few options. First, let's cover how to get out of this situation. If you perhaps weren't expecting conflicts and don't want to quite deal with the situation yet, you can simply back out of the merge with `git merge --abort`.

[source,console]
----
$ git status -sb
## master
UU hello.rb

$ git merge --abort

$ git status -sb
## master
----

The `git merge --abort` option tries to revert back to your state before you ran the merge. The only cases where it may not be able to do this perfectly would be if you had unstashed, uncommitted changes in your working directory when you ran it, otherwise it should work fine.

If for some reason you find yourself in a horrible state and just want to start over, you can also run `git reset --hard HEAD` or wherever you want to get back to. Remember again that this will blow away your working directory, so make sure you don't want any changes there.

===== Ignoring Whitespace

In this specific case, the conflicts are whitespace related. We know this because the case is simple, but it's also pretty easy to tell in real cases when looking at the conflict because every line is removed on one side and added again on the other. By default, Git sees all of these lines as being changed, so it can't merge the files.

The default merge strategy can take arguments though, and a few of them are about properly ignoring whitespace changes. If you see that you have a lot of whitespace issues in a merge, you can simply abort it and do it again, this time with `-Xignore-all-space` or `-Xignore-space-change`. The first option ignores changes in any **amount** of existing whitespace, the second ignores all whitespace changes altogether.

[source,console]
----
$ git merge -Xignore-all-space whitespace
Auto-merging hello.rb
Merge made by the 'recursive' strategy.
 hello.rb | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
----

Since in this case, the actual file changes were not conflicting, once we ignore the whitespace changes, everything merges just fine.

This is a lifesaver if you have someone on your team who likes to occasionally reformat everything from spaces to tabs or vice-versa.

[[_manual_remerge]]
===== Manual File Re-merging

Though Git handles whitespace pre-processing pretty well, there are other types of changes that perhaps Git can't handle automatically, but are scriptable fixes. As an example, let's pretend that Git could not handle the whitespace change and we needed to do it by hand.

What we really need to do is run the file we're trying to merge in through a `dos2unix` program before trying the actual file merge. So how would we do that?

First, we get into the merge conflict state. Then we want to get copies of my version of the file, their version (from the branch we're merging in) and the common version (from where both sides branched off). Then we want to fix up either their side or our side and re-try the merge again  for just this single file.

Getting the three file versions is actually pretty easy. Git stores all of these versions in the index under ``stages'' which each have numbers associated with them. Stage 1 is the common ancestor, stage 2 is your version and stage 3 is from the `MERGE_HEAD`, the version you're merging in (``theirs'').

You can extract a copy of each of these versions of the conflicted file with the `git show` command and a special syntax.

[source,console]
----
$ git show :1:hello.rb > hello.common.rb
$ git show :2:hello.rb > hello.ours.rb
$ git show :3:hello.rb > hello.theirs.rb
----

Si quieres ponerte un poco más intenso, también puedes usar el comando de plomería `ls-files -u` para obtener el verdadero SHA-1s de las manchas de Git para cada uno de los archivos. 

[source,console]
----
$ git ls-files -u
100755 ac51efdc3df4f4fd328d1a02ad05331d8e2c9111 1	hello.rb
100755 36c06c8752c78d2aff89571132f3bf7841a7b5c3 2	hello.rb
100755 e85207e04dfdd5eb0a1e9febbc67fd837c44a1cd 3	hello.rb
----

El `:1:hello.rb` es solo una clave para buscar esa mancha SHA-1.

Ahora que tenemos el contexto de estas tres etapas en nuestro directorio de trabajo, manualmente podemos arreglar los de ellos para solucionar los problemas de espacios en blanco y volver a fusionar el archivo con el poco conocido comando `git merge-file` que hace exactamente eso. 

[source,console]
----
$ dos2unix hello.theirs.rb
dos2unix: converting file hello.theirs.rb to Unix format ...

$ git merge-file -p \
    hello.ours.rb hello.common.rb hello.theirs.rb > hello.rb

$ git diff -w
diff --cc hello.rb
index 36c06c8,e85207e..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,8 -1,7 +1,8 @@@
  #! /usr/bin/env ruby

 +# prints out a greeting
  def hello
-   puts 'hello world'
+   puts 'hello mundo'
  end

  hello()
----

En este punto, hemos agradablemente fusionado el archivo. De hecho, esto en realidad funciona mejor que la opción de `ignore-all-space` porque esto realmente soluciona los cambios de los espacios en blanco antes de la fusión, en lugar de simplemente ignorarlo. En la fusión `ignore-all-space, realmente, terminamos con unas pocas líneas con finales de línea DOS, haciendo que las cosas se mezclen. 

Si quieres tener una idea antes de finalizar este compromiso sobre qué había cambiado en realidad entre un lado y el otro, puedes pedirle a `git diff` que compare qué hay en tu directorio de trabajo que estas a punto de comprometer como resultado de la fusión a cualquiera de estas etapas. Vamos a través de todas ellas. 

Para comparar el resultado con lo que tenías en tu rama antes de la fusión, en otra palabras, para ver lo que tu fusión insertó, puedes correr `git diff --ours`

[source,console]
----
$ git diff --ours
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index 36c06c8..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -2,7 +2,7 @@

 # prints out a greeting
 def hello
-  puts 'hello world'
+  puts 'hello mundo'
 end

 hello()
----

Así podemos observar fácilmente lo que sucedió en nuestra rama, lo que en realidad estamos insertando a este archivo con esta fusión, está cambiando solamente esa línea.

Si queremos ver cómo el resultado de la fusión difiere de lo que estaba del otro lado, puedes correr `git diff --theirs`. En este y el siguiente ejemplo, tenemos que usar `-w  para despojarse de los espacios en blanco porque lo estamos comparando con lo que está en Git, no con nuestro archivo limpio `hello.theirs.rb`

[source,console]
----
$ git diff --theirs -w
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index e85207e..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,5 +1,6 @@
 #! /usr/bin/env ruby

+# prints out a greeting
 def hello
   puts 'hello mundo'
 end
----

Finalmente, puedes observar cómo el archivo ha cambiado desde ambos lados con `git diff --base`.

[source,console]
----
$ git diff --base -w
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index ac51efd..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,7 +1,8 @@
 #! /usr/bin/env ruby

+# prints out a greeting
 def hello
-  puts 'hello world'
+  puts 'hello mundo'
 end

 hello()
----

En este punto podemos usar el comando `git clean` para limpiar los archivos sobrantes que creamos para hacer el manual de la fusión, pero que ya no necesitamos. 

[source,console]
----
$ git clean -f
Removing hello.common.rb
Removing hello.ours.rb
Removing hello.theirs.rb
----

[[_checking_out_conflicts]]
===== Revisando Los Conflictos

Tal vez en este punto no estemos felices con la resolución por alguna razón, o quizás manualmente editando uno o ambos lados todavía no funciona como es debido y necesitamos más contexto. 

Cambiemos el ejemplo un poco. Para este ejemplo, tenemos dos ramas de larga vida las cuales cada una tiene unos pocos cometidos en ellas aparte de crear un contenido de conflicto legítimo cuando es fusionado.

[source,console]
----
$ git log --graph --oneline --decorate --all
* f1270f7 (HEAD, master) update README
* 9af9d3b add a README
* 694971d update phrase to hola world
| * e3eb223 (mundo) add more tests
| * 7cff591 add testing script
| * c3ffff1 changed text to hello mundo
|/
* b7dcc89 initial hello world code
----

Ahora tenemos tres cometidos únicos que viven solo en la rama `principal` y tres otras que viven en la rama `mundo`. Si intentamos fusionar la rama mundo, generamos un conflicto.

[source,console]
----
$ git merge mundo
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Automatic merge failed; fix conflicts and then commit the result.
----

Nos gustaría ver cuál es el conflicto de fusión. Si abrimos el archivo, veremos algo así:

[source,ruby]
----
#! /usr/bin/env ruby

def hello
<<<<<<< HEAD
  puts 'hola world'
=======
  puts 'hello mundo'
>>>>>>> mundo
end

hello()
----

Ambos lados de la fusión han añadido contenido a este archivo, pero algunos de los cometidos han modificado el archivo en el mismo lugar que causó el conflicto. 

Exploremos un par de herramientas que ahora tienes a tu disposición para determinar cómo el conflicto resultó ser. Tal vez no es tan obvio qué tan exactamente deberías solucionar este problema. Necesitas más contexto.

Una herramienta útil es `git checkout` con la opción  ‘--conflicto’. Esto revisará el archivo de nuevo y reemplazará los marcadores de conflicto de la fusión. Esto puede ser útil si quieres reiniciar los marcadores y tratar de resolverlos de nuevo. 

Puedes pasar `--conflict` en lugar de `diff3` o `merge` (lo que es por defecto). Si pasas `diff3`, Git usará una versión un poco diferente de marcadores de conflicto, no solo dándote ``ours'' versión y la versión de ``theirs'', sino también la versión ``base'' en línea para darte más contexto.

[source,console]
----
$ git checkout --conflict=diff3 hello.rb
----

Una vez que corremos eso, en su lugar el archivo se verá así:

[source,ruby]
----
#! /usr/bin/env ruby

def hello
<<<<<<< ours
  puts 'hola world'
||||||| base
  puts 'hello world'
=======
  puts 'hello mundo'
>>>>>>> theirs
end

hello()
----

Si este formato es de tu agrado, puedes configurarlo como defecto para futuros conflictos de fusión al colocar el `merge.conflictstyle` configurándolo a `diff3`.

[source,console]
----
$ git config --global merge.conflictstyle diff3
----

El comando `git checkout` puede también  tomar la opción de `--ellos`o la `--nuestra`, lo cual puede ser una manera mucho más rápida de escoger un lado o el otro sin tener que fusionar las cosas en lo absoluto.

Esto puede ser particularmente útil para conflictos de archivos binarios donde simplemente puedes escoger un lado, o donde solo quieres fusionar ciertos archivos desde otra rama – puedes hacer la fusión y luego revisar ciertos archivos de un lado o del otro antes de comprometerlos

[[_merge_log]]
===== Registro de Fusión

Otra herramienta útil al resolver conflictos de fusión es `git log`. Esto puede ayudarte a tener contexto a lo que pudo haber contribuido a los conflictos. Revisando un poco de historial para recordar por qué dos líneas de desarrollo estaban tocando el mismo código de área puede ser muy útil algunas veces.

Para obtener una lista completa de cometidos únicos que fueron incluidos en cualquiera de las ramas involucradas en esta fusión, podemos usar la sintaxis ``triple dot'' (triple punto) que aprendimos en <<_triple_dot>>.

[source,console]
----
$ git log --oneline --left-right HEAD...MERGE_HEAD
< f1270f7 update README
< 9af9d3b add a README
< 694971d update phrase to hola world
> e3eb223 add more tests
> 7cff591 add testing script
> c3ffff1 changed text to hello mundo
----

Esa es una buena lista de los seis compromisos involucrados, así como en qué línea de desarrollo estuvo cada compromiso.

Sin embargo, podemos simplificar aún más esto para darnos un contexto mucho más específico. Si añadimos  la opción `--merge` a `git log`, solo mostrará los compromisos en cualquier lado de la fusión que toque un archivo que esté actualmente en conflicto.

[source,console]
----
$ git log --oneline --left-right --merge
< 694971d update phrase to hola world
> c3ffff1 changed text to hello mundo
----

En su lugar, si corremos eso con la opción `-p` obtienes, solo los diffs del archivo que terminó en conflicto. Esto puede ser **bastante**útil al rápidamente darte el contexto que necesitas para ayudarte a entender por qué algo crea problemas y cómo resolverlo de una forma más inteligente.

===== Formato Diff Combinado

Dado que las etapas de Git clasifican los resultados que tienen éxito, cuando corres `git diff` mientras está en un estado de conflicto de fusión, solo puedes obtener lo que está actualmente en conflicto. Esto puede ser útil para ver lo que todavía debes resolver. 

Cuando corres directamente `git diff` después de un conflicto de fusión, te dará la información en un formato de salida diff bastante único.

[source,console]
----
$ git diff
diff --cc hello.rb
index 0399cd5,59727f0..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,11 @@@
  #! /usr/bin/env ruby

  def hello
++<<<<<<< HEAD
 +  puts 'hola world'
++=======
+   puts 'hello mundo'
++>>>>>>> mundo
  end

  hello()
----

El formato es llamado ``Diff combinado'' y proporciona dos columnas de datos al lado de cada línea. La primera columna muestra si esa línea es diferente (añadido o removido) entre la rama ``nuestra'' y el archivo en tu directorio de trabajo, y la segunda columna hace lo mismo entre la rama “de ellos” y la copia de tu directorio de trabajo.

Así que en ese ejemplo se puede observar que las líneas <<<<<<< y >>>>>>> están en la copia de trabajo, pero no en ningún lado de la fusión. Esto tiene sentido porque la herramienta de fusión las mantiene ahí para nuestro contexto, pero se espera removamos. 

If we resolve the conflict and run `git diff` again, we'll see the same thing, but it's a little more useful.

[source,console]
----
$ vim hello.rb
$ git diff
diff --cc hello.rb
index 0399cd5,59727f0..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,7 @@@
  #! /usr/bin/env ruby

  def hello
-   puts 'hola world'
 -  puts 'hello mundo'
++  puts 'hola mundo'
  end

  hello()
----

This shows us that ``hola world'' was in our side but not in the working copy, that ``hello mundo'' was in their side but not in the working copy and finally that ``hola mundo'' was not in either side but is now in the working copy. This can be useful to review before committing the resolution.

You can also get this from the `git log` for any merge after the fact to see how something was resolved after the fact. Git will output this format if you run `git show` on a merge commit, or if you add a `--cc` option to a `git log -p` (which by default only shows patches for non-merge commits).

[source,console]
----
$ git log --cc -p -1
commit 14f41939956d80b9e17bb8721354c33f8d5b5a79
Merge: f1270f7 e3eb223
Author: Scott Chacon <schacon@gmail.com>
Date:   Fri Sep 19 18:14:49 2014 +0200

    Merge branch 'mundo'

    Conflicts:
        hello.rb

diff --cc hello.rb
index 0399cd5,59727f0..e1d0799
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,7 @@@
  #! /usr/bin/env ruby

  def hello
-   puts 'hola world'
 -  puts 'hello mundo'
++  puts 'hola mundo'
  end

  hello()
----

[[_undoing_merges]]
==== Undoing Merges

Now that you know how to create a merge commit, you'll probably make some by mistake.
One of the great things about working with Git is that it's okay to make mistakes, because it's possible (and in many cases easy) to fix them.

Merge commits are no different.
Let's say you started work on a topic branch, accidentally merged it into `master`, and now your commit history looks like this:

.Accidental merge commit
image::images/undomerge-start.png[Accidental merge commit.]

There are two ways to approach this problem, depending on what your desired outcome is.

===== Fix the references

If the unwanted merge commit only exists on your local repository, the easiest and best solution is to move the branches so that they point where you want them to.
In most cases, if you follow the errant `git merge` with `git reset --hard HEAD~`, this will reset the branch pointers so they look like this:

.History after `git reset --hard HEAD~`
image::images/undomerge-reset.png[History after `git reset --hard HEAD~`.]

We covered `reset` back in <<_git_reset>>, so it shouldn't be too hard to figure out what's going on here.
Here's a quick refresher: `reset --hard` usually goes through three steps:

. Move the branch HEAD points to.
  In this case, we want to move `master` to where it was before the merge commit (`C6`).
. Make the index look like HEAD.
. Make the working directory look like the index.

The downside of this approach is that it's rewriting history, which can be problematic with a shared repository.
Check out <<_rebase_peril>> for more on what can happen; the short version is that if other people have the commits you're rewriting, you should probably avoid `reset`.
This approach also won't work if any other commits have been created since the merge; moving the refs would effectively lose those changes.

[[_reverse_commit]]
===== Reverse the commit

If moving the branch pointers around isn't going to work for you, Git gives you the option of making a new commit which undoes all the changes from an existing one.
Git calls this operation a ``revert'', and in this particular scenario, you'd invoke it like this:

[source,console]
----
$ git revert -m 1 HEAD
[master b1d8379] Revert "Merge branch 'topic'"
----

The `-m 1` flag indicates which parent is the ``mainline'' and should be kept.
When you invoke a merge into `HEAD` (`git merge topic`), the new commit has two parents: the first one is `HEAD` (`C6`), and the second is the tip of the branch being merged in (`C4`).
In this case, we want to undo all the changes introduced by merging in parent #2 (`C4`), while keeping all the content from parent #1 (`C6`).

The history with the revert commit looks like this:

.History after `git revert -m 1`
image::images/undomerge-revert.png[History after `git revert -m 1`.]

The new commit `^M` has exactly the same contents as `C6`, so starting from here it's as if the merge never happened, except that the now-unmerged commits are still in `HEAD`'s history.
Git will get confused if you try to merge `topic` into `master` again:

[source,console]
----
$ git merge topic
Already up-to-date.
----

There's nothing in `topic` that isn't already reachable from `master`.
What's worse, if you add work to `topic` and merge again, Git will only bring in the changes _since_ the reverted merge:

.History with a bad merge
image::images/undomerge-revert2.png[History with a bad merge.]

The best way around this is to un-revert the original merge, since now you want to bring in the changes that were reverted out, *then* create a new merge commit:

[source,console]
----
$ git revert ^M
[master 09f0126] Revert "Revert "Merge branch 'topic'""
$ git merge topic
----

.History after re-merging a reverted merge
image::images/undomerge-revert3.png[History after re-merging a reverted merge.]

In this example, `M` and `^M` cancel out.
`^^M` effectively merges in the changes from `C3` and `C4`, and `C8` merges in the changes from `C7`, so now `topic` is fully merged.

==== Other Types of Merges

So far we've covered the normal merge of two branches, normally handled with what is called the ``recursive'' strategy of merging. There are other ways to merge branches together however. Let's cover a few of them quickly.

===== Our or Theirs Preference

First of all, there is another useful thing we can do with the normal ``recursive'' mode of merging. We've already seen the `ignore-all-space` and `ignore-space-change` options which are passed with a `-X` but we can also tell Git to favor one side or the other when it sees a conflict.

By default, when Git sees a conflict between two branches being merged, it will add merge conflict markers into your code and mark the file as conflicted and let you resolve it. If you would prefer for Git to simply choose a specific side and ignore the other side instead of letting you manually merge the conflict, you can pass the `merge` command either a `-Xours` or `-Xtheirs`.

If Git sees this, it will not add conflict markers. Any differences that are mergeable, it will merge. Any differences that conflict, it will simply choose the side you specify in whole, including binary files.

If we go back to the ``hello world'' example we were using before, we can see that merging in our branch causes conflicts.

[source,console]
----
$ git merge mundo
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Resolved 'hello.rb' using previous resolution.
Automatic merge failed; fix conflicts and then commit the result.
----

However if we run it with `-Xours` or `-Xtheirs` it does not.

[source,console]
----
$ git merge -Xours mundo
Auto-merging hello.rb
Merge made by the 'recursive' strategy.
 hello.rb | 2 +-
 test.sh  | 2 ++
 2 files changed, 3 insertions(+), 1 deletion(-)
 create mode 100644 test.sh
----

In that case, instead of getting conflict markers in the file with ``hello mundo'' on one side and ``hola world'' on the other, it will simply pick ``hola world''. However, all the other non-conflicting changes on that branch are merged successfully in.

This option can also be passed to the `git merge-file` command we saw earlier by running something like `git merge-file --ours` for individual file merges.

If you want to do something like this but not have Git even try to merge changes from the other side in, there is a more draconian option, which is the ``ours'' merge _strategy_. This is different from the ``ours'' recursive merge _option_.

This will basically do a fake merge. It will record a new merge commit with both branches as parents, but it will not even look at the branch you're merging in. It will simply record as the result of the merge the exact code in your current branch.

[source,console]
----
$ git merge -s ours mundo
Merge made by the 'ours' strategy.
$ git diff HEAD HEAD~
$
----

You can see that there is no difference between the branch we were on and the result of the merge.

This can often be useful to basically trick Git into thinking that a branch is already merged when doing a merge later on. For example, say you branched off a ``release'' branch and have done some work on it that you will want to merge back into your ``master'' branch at some point. In the meantime some bugfix on ``master'' needs to be backported into your `release` branch. You can merge the bugfix branch into the `release` branch and also `merge -s ours` the same branch into your `master` branch (even though the fix is already there) so when you later merge the `release` branch again, there are no conflicts from the bugfix.

include::subtree-merges.asc[]
