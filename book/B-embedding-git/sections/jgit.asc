=== JGit

(((jgit)))(((java)))
Si deseas utilizar Git desde dentro de un programa Java, hay una biblioteca Git completamente funcional llamada JGit. 
JGit es una implementación relativamente completa de Git escrita de forma nativa en Java, y que se utiliza ampliamente en la comunidad Java.
El proyecto JGit está bajo el paraguas de Eclipse, y su "casa" puede encontrarse en http://www.eclipse.org/jgit[].

==== Getting Set Up

Hay varias formas de conectar tu proyecto con JGit y empezar a escribir código usando éste.
Probablemente la más fácil sea utilizar Maven -la integración se consigue añadiendo el siguiente fragmento a la etiqueta `<dependencies>` en tu archivo pom.xml:

[source,xml]
----
<dependency>
    <groupId>org.eclipse.jgit</groupId>
    <artifactId>org.eclipse.jgit</artifactId>
    <version>3.5.0.201409260305-r</version>
</dependency>
----

La `version` es bastante probable que habrá avanzado para el momento en que leas esto; comprueba http://mvnrepository.com/artifact/org.eclipse.jgit/org.eclipse.jgit[] para obtener información actualizada del repositorio.
Una vez que se realiza este paso, Maven automáticamente adquirirá y utilizará las bibliotecas JGit que necesites.

Si prefieres gestionar las dependencias binarias tú mismo, binarios JGit pre-construidos están disponibles en http://www.eclipse.org/jgit/download[].
Puedes construirlos en tu proyecto ejecutando un comando como el siguiente:

[source,console]
----
javac -cp .:org.eclipse.jgit-3.5.0.201409260305-r.jar App.java
java -cp .:org.eclipse.jgit-3.5.0.201409260305-r.jar App
----

==== Fontanería

JGit tiene dos niveles básicos de la API: fontanería y porcelana.
La terminología de éstos proviene de Git, y JGit se divide en más o menos los mismos tipos de áreas: las API de porcelana son un front-end amigable para las acciones comunes a nivel de usuario (el tipo de cosas para las que un usuario normal utilizaría la herramienta de línea de comandos de Git), mientras que las API de fontanería son para interactuar directamente a bajo nivel con los objetos del repositorio.

El punto de partida para la mayoría de las sesiones JGit es la clase `Repository`, y la primera cosa que querrás hacer es crear una instancia de la misma. 
Para un repositorio basado en sistema de archivos (sí, JGit permite otros modelos de almacenamiento), esto se logra utilizando `FileRepositoryBuilder`:

[source,java]
----
// Create a new repository; the path must exist
Repository newlyCreatedRepo = FileRepositoryBuilder.create(
    new File("/tmp/new_repo/.git"));

// Open an existing repository
Repository existingRepo = new FileRepositoryBuilder()
    .setGitDir(new File("my_repo/.git"))
    .build();
----

El constructor tiene una API fluida para proporcionar todo lo que necesitas para encontrar un repositorio Git, tanto si tu programa sabe exactamente donde se encuentra como si no.
Puede utilizar variables de entorno ((`.readEnvironment()`), empezar a partir de un lugar en el directorio de trabajo y buscar (`.setWorkTree(…).findGitDir()`), o simplemente abrir un directorio `.git` conocido como más arriba.

Una vez que tengas una instancia `Repository`, se pueden hacer todo tipo de cosas con ella. He aquí una muestra rápida:

[source,java]
----
// Get a reference
Ref master = repo.getRef("master");

// Get the object the reference points to
ObjectId masterTip = master.getObjectId();

// Rev-parse
ObjectId obj = repo.resolve("HEAD^{tree}");

// Load raw object contents
ObjectLoader loader = repo.open(masterTip);
loader.copyTo(System.out);

// Create a branch
RefUpdate createBranch1 = repo.updateRef("refs/heads/branch1");
createBranch1.setNewObjectId(masterTip);
createBranch1.update();

// Delete a branch
RefUpdate deleteBranch1 = repo.updateRef("refs/heads/branch1");
deleteBranch1.setForceUpdate(true);
deleteBranch1.delete();

// Config
Config cfg = repo.getConfig();
String name = cfg.getString("user", null, "name");
----

Hay bastantes cosas que suceden aquí, así que vamos a examinarlo sección a sección.

La primera línea consigue un puntero a la referencia `master`.
JGit obtiene automáticamente la referencia master _real_, que reside en `refs/heads/master`, y devuelve un objeto que te permite obtener información acerca de la referencia.
Puedes obtener el nombre (`.getName()`), y también el objeto destino de una referencia directa (`.getObjectId()`) o la referencia a la que apunta mediante una referencia simbólica (`.getTarget()`). 
Los objetos Ref también se utilizan para representar referencias a etiquetas y objetos, por lo que puedes preguntar si la etiqueta está ''pelada'', lo que significa que apunta al objetivo final de una (potencialmente larga) cadena de texto de objetos etiqueta.

La segunda línea obtiene el destino de la referencia `master`, que se devuelve como una instancia ObjectId.
ObjectId representa el hash SHA-1 de un objeto, que podría o no existir en la base de datos de objetos de Git.
La tercera línea es similar, pero muestra cómo maneja JGit la sintaxis rev-parse (para más información sobre esto, consulta  <<_branch_references>>); puedes pasar cualquier especificador de objeto que Git entienda, y JGit devolverá una ObjectId válida para ese objeto, o `null`.

Las dos líneas siguientes muestran cómo cargar el contenido en bruto de un objeto.
En este ejemplo, llamamos a `ObjectLoader.copyTo()` para transmitir el contenido del objeto directamente a la salida estándar, pero ObjectLoader también tiene métodos para leer el tipo y el tamaño de un objeto, así como devoverlo como un array de bytes.
Para objetos grandes (donde `.isLarge()` devuelve true), puedes llamar a `.openStream()` para obtener un objeto similar a InputStream del cual puedes leer los datos del objeto en bruto si almacenarlo en memoria en seguida.

The next few lines show what it takes to create a new branch.
We create a RefUpdate instance, configure some parameters, and call `.update()` to trigger the change.
Directly following this is the code to delete that same branch.
Note that `.setForceUpdate(true)` is required for this to work; otherwise the `.delete()` call will return `REJECTED`, and nothing will happen.

The last example shows how to fetch the `user.name` value from the Git configuration files.
This Config instance uses the repository we opened earlier for local configuration, but will automatically detect the global and system configuration files and read values from them as well.

This is only a small sampling of the full plumbing API; there are many more methods and classes available.
Also not shown here is the way JGit handles errors, which is through the use of exceptions.
JGit APIs sometimes throw standard Java exceptions (such as `IOException`), but there are a host of JGit-specific exception types that are provided as well (such as `NoRemoteRepositoryException`, `CorruptObjectException`, and `NoMergeBaseException`).

==== Porcelana

The plumbing APIs are rather complete, but it can be cumbersome to string them together to achieve common goals, like adding a file to the index, or making a new commit.
JGit provides a higher-level set of APIs to help out with this, and the entry point to these APIs is the `Git` class:

[source,java]
----
Repository repo;
// construct repo...
Git git = new Git(repo);
----

The Git class has a nice set of high-level _builder_-style methods that can be used to construct some pretty complex behavior.
Let's take a look at an example – doing something like `git ls-remote`:

[source,java]
----
CredentialsProvider cp = new UsernamePasswordCredentialsProvider("username", "p4ssw0rd");
Collection<Ref> remoteRefs = git.lsRemote()
    .setCredentialsProvider(cp)
    .setRemote("origin")
    .setTags(true)
    .setHeads(false)
    .call();
for (Ref ref : remoteRefs) {
    System.out.println(ref.getName() + " -> " + ref.getObjectId().name());
}
----

This is a common pattern with the Git class; the methods return a command object that lets you chain method calls to set parameters, which are executed when you call `.call()`.
In this case, we're asking the `origin` remote for tags, but not heads.
Also notice the use of a `CredentialsProvider` object for authentication.

Many other commands are available through the Git class, including but not limited to `add`, `blame`, `commit`, `clean`, `push`, `rebase`, `revert`, and `reset`.

==== Otras Lecturas

Esta es sólo una pequeña muestra de todas las posibilidades de JGit.
Si estás interesado y deseas aprender más, aquí tienes dónde buscar información e inspiración:

* La documentación API oficial de JGit está disponible en línea en http://download.eclipse.org/jgit/docs/latest/apidocs[].      Estos son Javadoc estándar, por lo que tu IDE JVM favorito será capaz de instalarlos de forma local, también.
* El "libro de cocina" de JGit en https://github.com/centic9/jgit-cookbook[] tiene muchos ejemplos de cómo realizar tareas específicas con JGit.
* Hay varios buenos recursos indicados en http://stackoverflow.com/questions/6861881[].
