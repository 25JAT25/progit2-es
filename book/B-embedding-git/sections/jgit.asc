=== JGit

(((jgit)))(((java)))
Si deseas utilizar Git desde dentro de un programa Java, hay una biblioteca Git completamente funcional llamada JGit. 
JGit es una implementación relativamente completa de Git escrita de forma nativa en Java, y que se utiliza ampliamente en la comunidad Java.
El proyecto JGit está bajo el paraguas de Eclipse, y su "casa" puede encontrarse en http://www.eclipse.org/jgit[].

==== Getting Set Up

Hay varias formas de conectar tu proyecto con JGit y empezar a escribir código usando éste.
Probablemente la más fácil sea utilizar Maven -la integración se consigue añadiendo el siguiente fragmento a la etiqueta `<dependencies>` en tu archivo pom.xml:

[source,xml]
----
<dependency>
    <groupId>org.eclipse.jgit</groupId>
    <artifactId>org.eclipse.jgit</artifactId>
    <version>3.5.0.201409260305-r</version>
</dependency>
----

La `version` es bastante probable que habrá avanzado para el momento en que leas esto; comprueba http://mvnrepository.com/artifact/org.eclipse.jgit/org.eclipse.jgit[] para obtener información actualizada del repositorio.
Una vez que se realiza este paso, Maven automáticamente adquirirá y utilizará las bibliotecas JGit que necesites.

Si prefieres gestionar las dependencias binarias tú mismo, binarios JGit pre-construidos están disponibles en http://www.eclipse.org/jgit/download[].
Puedes construirlos en tu proyecto ejecutando un comando como el siguiente:

[source,console]
----
javac -cp .:org.eclipse.jgit-3.5.0.201409260305-r.jar App.java
java -cp .:org.eclipse.jgit-3.5.0.201409260305-r.jar App
----

==== Fontanería

JGit tiene dos niveles básicos de la API: fontanería y porcelana.
La terminología de éstos proviene de Git, y JGit se divide en más o menos los mismos tipos de áreas: las API de porcelana son un front-end amigable para las acciones comunes a nivel de usuario (el tipo de cosas para las que un usuario normal utilizaría la herramienta de línea de comandos de Git), mientras que las API de fontanería son para interactuar directamente a bajo nivel con los objetos del repositorio.

El punto de partida para la mayoría de las sesiones JGit es la clase `Repository`, y la primera cosa que querrás hacer es crear una instancia de la misma. 
Para un repositorio basado en sistema de archivos (sí, JGit permite otros modelos de almacenamiento), esto se logra utilizando `FileRepositoryBuilder`:

[source,java]
----
// Create a new repository; the path must exist
Repository newlyCreatedRepo = FileRepositoryBuilder.create(
    new File("/tmp/new_repo/.git"));

// Open an existing repository
Repository existingRepo = new FileRepositoryBuilder()
    .setGitDir(new File("my_repo/.git"))
    .build();
----

El constructor tiene una API fluida para proporcionar todo lo que necesitas para encontrar un repositorio Git, tanto si tu programa sabe exactamente donde se encuentra como si no.
Puede utilizar variables de entorno ((`.readEnvironment()`), empezar a partir de un lugar en el directorio de trabajo y buscar (`.setWorkTree(…).findGitDir()`), o simplemente abrir un directorio `.git` conocido como más arriba.

Una vez que tengas una instancia `Repository`, se pueden hacer todo tipo de cosas con ella. He aquí una muestra rápida:

[source,java]
----
// Get a reference
Ref master = repo.getRef("master");

// Get the object the reference points to
ObjectId masterTip = master.getObjectId();

// Rev-parse
ObjectId obj = repo.resolve("HEAD^{tree}");

// Load raw object contents
ObjectLoader loader = repo.open(masterTip);
loader.copyTo(System.out);

// Create a branch
RefUpdate createBranch1 = repo.updateRef("refs/heads/branch1");
createBranch1.setNewObjectId(masterTip);
createBranch1.update();

// Delete a branch
RefUpdate deleteBranch1 = repo.updateRef("refs/heads/branch1");
deleteBranch1.setForceUpdate(true);
deleteBranch1.delete();

// Config
Config cfg = repo.getConfig();
String name = cfg.getString("user", null, "name");
----

There's quite a bit going on here, so let's go through it one section at a time.

The first line gets a pointer to the `master` reference.
JGit automatically grabs the _actual_ master ref, which lives at `refs/heads/master`, and returns an object that lets you fetch information about the reference.
You can get the name (`.getName()`), and either the target object of a direct reference (`.getObjectId()`) or the reference pointed to by a symbolic ref (`.getTarget()`).
Ref objects are also used to represent tag refs and objects, so you can ask if the tag is ``peeled,'' meaning that it points to the final target of a (potentially long) string of tag objects.

The second line gets the target of the `master` reference, which is returned as an ObjectId instance.
ObjectId represents the SHA-1 hash of an object, which might or might not exist in Git's object database.
The third line is similar, but shows how JGit handles the rev-parse syntax (for more on this, see <<_branch_references>>); you can pass any object specifier that Git understands, and JGit will return either a valid ObjectId for that object, or `null`.

The next two lines show how to load the raw contents of an object.
In this example, we call `ObjectLoader.copyTo()` to stream the contents of the object directly to stdout, but ObjectLoader also has methods to read the type and size of an object, as well as return it as a byte array.
For large objects (where `.isLarge()` returns `true`), you can call `.openStream()` to get an InputStream-like object that can read the raw object data without pulling it all into memory at once.

The next few lines show what it takes to create a new branch.
We create a RefUpdate instance, configure some parameters, and call `.update()` to trigger the change.
Directly following this is the code to delete that same branch.
Note that `.setForceUpdate(true)` is required for this to work; otherwise the `.delete()` call will return `REJECTED`, and nothing will happen.

The last example shows how to fetch the `user.name` value from the Git configuration files.
This Config instance uses the repository we opened earlier for local configuration, but will automatically detect the global and system configuration files and read values from them as well.

This is only a small sampling of the full plumbing API; there are many more methods and classes available.
Also not shown here is the way JGit handles errors, which is through the use of exceptions.
JGit APIs sometimes throw standard Java exceptions (such as `IOException`), but there are a host of JGit-specific exception types that are provided as well (such as `NoRemoteRepositoryException`, `CorruptObjectException`, and `NoMergeBaseException`).

==== Porcelana

The plumbing APIs are rather complete, but it can be cumbersome to string them together to achieve common goals, like adding a file to the index, or making a new commit.
JGit provides a higher-level set of APIs to help out with this, and the entry point to these APIs is the `Git` class:

[source,java]
----
Repository repo;
// construct repo...
Git git = new Git(repo);
----

The Git class has a nice set of high-level _builder_-style methods that can be used to construct some pretty complex behavior.
Let's take a look at an example – doing something like `git ls-remote`:

[source,java]
----
CredentialsProvider cp = new UsernamePasswordCredentialsProvider("username", "p4ssw0rd");
Collection<Ref> remoteRefs = git.lsRemote()
    .setCredentialsProvider(cp)
    .setRemote("origin")
    .setTags(true)
    .setHeads(false)
    .call();
for (Ref ref : remoteRefs) {
    System.out.println(ref.getName() + " -> " + ref.getObjectId().name());
}
----

This is a common pattern with the Git class; the methods return a command object that lets you chain method calls to set parameters, which are executed when you call `.call()`.
In this case, we're asking the `origin` remote for tags, but not heads.
Also notice the use of a `CredentialsProvider` object for authentication.

Many other commands are available through the Git class, including but not limited to `add`, `blame`, `commit`, `clean`, `push`, `rebase`, `revert`, and `reset`.

==== Otras Lecturas

Esta es sólo una pequeña muestra de todas las posibilidades de JGit.
Si estás interesado y deseas aprender más, aquí tienes dónde buscar información e inspiración:

* La documentación API oficial de JGit está disponible en línea en http://download.eclipse.org/jgit/docs/latest/apidocs[].      Estos son Javadoc estándar, por lo que tu IDE JVM favorito será capaz de instalarlos de forma local, también.
* El "libro de cocina" de JGit en https://github.com/centic9/jgit-cookbook[] tiene muchos ejemplos de cómo realizar tareas específicas con JGit.
* Hay varios buenos recursos indicados en http://stackoverflow.com/questions/6861881[].
