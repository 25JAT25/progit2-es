[[_git_hooks]]
=== Puntos de enganche en Git

(((hooks)))
Al igual que en otros sistemas de control de versiones, Git también cuenta
con mecanismos para lanzar scrips de usuario cuando suceden ciertas acciones
importantes, llamados puntos de enganche (hooks). Hay dos grupos de esos
puntos de lanzamiento: los del lado
cliente y los del lado servidor. Los puntos del lado cliente están relacionados
con operaciones tales como la confirmación de cambios (commit) o la fusión
(merge). Los del lado servidor están relacionados con operaciones tales como
la recepción de contenidos enviados (push) a un servidor. Estos puntos de
enganche pueden utilizarse para multitud de aplicaciones. Vamos a ver unas
pocas de ellas.


==== Instalación de un punto de enganche

Los puntos de enganche se guardan en la subcarpeta 'hooks' de la carpeta Git.
En la mayoría de proyectos, estará en `.git/hooks`. Por defecto, esta carpeta
contiene unos cuantos scripts de ejemplo. Algunos de ellos son útiles por sí
mismos; pero su misión principal es la de documentar las variables de entrada
para cada script. Todos los ejemplos se han escrito como scripts de shell,
con algo de código Perl embebido en ellos. Pero cualquier tipo de script
ejecutable que tenga el nombre adecuado puede servir igual de bien. Los puedes
escribir en Ruby o en Python o en cualquier lenguaje de scripting con el que
trabajes. Si quieres usar los ejemplos que trae Git, tendrás que renombrarlos,
ya que los ejemplos acaban su nombre en `.sample`.

Para activar un punto de enganche para un script, pon el archivo
correspondiente en la carpeta `hooks`; con el nombre adecuado y con la marca
de ejecutable. A partir de ese momento, será automáticamente lanzado cuando se
dé la acción correspondiente. Vamos a ver la mayoría de nombres de puntos de
enganche disponibles.

==== Puntos de enganche del lado cliente

Hay muchos de ellos. En esta sección los dividiremos en puntos de enganche en
el flujo de trabajo de confirmación de cambios, puntos en el flujo de trabajo
de correo electrónico y todos los demás.

[NOTE]
====
Observa que los puntos de enganche del lado del cliente *no se copian* cuando
clonas el repositorio. Si quieres que tengan un efecto para forzar una política
es necesario que esté en el lado del cliente. Por ejemplo, mira en
<<_an_example_git_enforced_policy>>.
====

===== Puntos en el flujo de trabajo de confirmación de cambios

Los primeros cuatro puntos de enganche están relacionados con el proceso de
confirmación de cambios. 

Primero se activa el punto de enganche `pre-commit`, incluso antes de que
teclees el mensaje de confirmación. Se suele utilizar para inspeccionar
la instantánea (snapshot) que vas a confirmar, para ver si has olvidado
algo, para asegurar que las pruebas se ejecutan, o para revisar cualquier
aspecto que necesites inspeccionar en el codigo. Saliendo con un valor
de retorno distinto de cero, se aborta la confirmación de cambios. Aunque
siempre puedes saltartelo con la orden `git commit --no-verify`. Puede ser
util para realizar tareas tales como revisar el estilo del código
(lanzando `lint` o algo equivalente), revisar los espacios en blanco de
relleno (el script de ejemplo hace exactamente eso), o revisar si todos
los nuevos métodos llevan la adecuada documentación.

El punto de enganche `prepare-commit-msg` se activa antes de arrancar
el editor del mensaje de confirmación de cambios, pero después de crearse
el mensaje por defecto. Te permite editar el mensaje por defecto, antes
de que lo vea el autor de la confirmación de cambios. Este punto de
enganche recibe varias entradas: la ubicación (path) del archivo temporal
donde se almacena el mensaje de confirmación, el tipo de confirmación y la
clave SHA-1 si estamos enmendando un commit existente. Este punto de enganche
no tiene mucha utilidad para las confirmaciones de cambios normales; pero sí
para las confirmaciones donde el mensaje por defecto es autogenerado, como
en las confirmaciones de fusiones (merge), los mensajes con plantilla, las
confirmaciones aplastadas (squash), o las confirmaciones de correccion
(amend). Se puede utilizar combinandolo con una plantilla de confirmación,
para poder insertar información automáticamente.

El punto de enganche `commit-msg` recibe un parámetro: la ubicación
(path) del archivo temporal que contiene el mensaje de confirmación actual.
Si este script termina con un código de salida distinto de cero, Git aborta
el proceso de confirmación de cambios; permitiendo así validar el estado
del proyecto o el mensaje de confirmación antes de permitir continuar. En
la última parte de este capítulo, veremos cómo podemos utilizar este punto
de enganche para revisar si el mensaje de confirmación es conforme a un
determinado patrón obligatorio.

Despues de completar todo el proceso de confirmación de cambios, es cuando
se lanza el punto de enganche `post-commit`. Este no recibe ningún parámetro,
pero podemos obtener facilmente la última confirmación de cambios con el
comando `git log -1 HEAD`. Habitualmente, este script final se suele utilizar
para realizar notificaciones o tareas similares.

[[_email_hooks]]
===== E-mail Workflow Hooks

You can set up three client-side hooks for an e-mail-based workflow.
They're all invoked by the `git am` command, so if you aren't using that command in your workflow, you can safely skip to the next section.
If you're taking patches over e-mail prepared by `git format-patch`, then some of these may be helpful to you.

The first hook that is run is `applypatch-msg`.
It takes a single argument: the name of the temporary file that contains the proposed commit message.
Git aborts the patch if this script exits non-zero.
You can use this to make sure a commit message is properly formatted, or to normalize the message by having the script edit it in place.

The next hook to run when applying patches via `git am` is `pre-applypatch`.
Somewhat confusingly, it is run _after_ the patch is applied but before a commit is made, so you can use it to inspect the snapshot before making the commit.
You can run tests or otherwise inspect the working tree with this script.
If something is missing or the tests don't pass, exiting non-zero aborts the `git am` script without committing the patch.

The last hook to run during a `git am` operation is `post-applypatch`, which runs after the commit is made.
You can use it to notify a group or the author of the patch you pulled in that you've done so.
You can't stop the patching process with this script.

[[_other_client_hooks]]
===== Other Client Hooks

The `pre-rebase` hook runs before you rebase anything and can halt the process by exiting non-zero.
You can use this hook to disallow rebasing any commits that have already been pushed.
The example `pre-rebase` hook that Git installs does this, although it makes some assumptions that may not match with your workflow.

The `post-rewrite` hook is run by commands that replace commits, such as `git commit --amend` and `git rebase` (though not by `git filter-branch`).
Its single argument is which command triggered the rewrite, and it receives a list of rewrites on `stdin`.
This hook has many of the same uses as the `post-checkout` and `post-merge` hooks.

After you run a successful `git checkout`, the `post-checkout` hook runs; you can use it to set up your working directory properly for your project environment.
This may mean moving in large binary files that you don't want source controlled, auto-generating documentation, or something along those lines.

The `post-merge` hook runs after a successful `merge` command.
You can use it to restore data in the working tree that Git can't track, such as permissions data.
This hook can likewise validate the presence of files external to Git control that you may want copied in when the working tree changes.

The `pre-push` hook runs during `git push`, after the remote refs have been updated but before any objects have been transferred.
It receives the name and location of the remote as parameters, and a list of to-be-updated refs through `stdin`.
You can use it to validate a set of ref updates before a push occurs (a non-zero exit code will abort the push).

Git occasionally does garbage collection as part of its normal operation, by invoking `git gc --auto`.
The `pre-auto-gc` hook is invoked just before the garbage collection takes place, and can be used to notify you that this is happening, or to abort the collection if now isn't a good time.

==== Server-Side Hooks

In addition to the client-side hooks, you can use a couple of important server-side hooks as a system administrator to enforce nearly any kind of policy for your project.
These scripts run before and after pushes to the server.
The pre hooks can exit non-zero at any time to reject the push as well as print an error message back to the client; you can set up a push policy that's as complex as you wish.

===== `pre-receive`

The first script to run when handling a push from a client is `pre-receive`.
It takes a list of references that are being pushed from stdin; if it exits non-zero, none of them are accepted.
You can use this hook to do things like make sure none of the updated references are non-fast-forwards, or to do access control for all the refs and files they're modifying with the push.

===== `update`

The `update` script is very similar to the `pre-receive` script, except that it's run once for each branch the pusher is trying to update.
If the pusher is trying to push to multiple branches, `pre-receive` runs only once, whereas update runs once per branch they're pushing to.
Instead of reading from stdin, this script takes three arguments: the name of the reference (branch), the SHA-1 that reference pointed to before the push, and the SHA-1 the user is trying to push.
If the update script exits non-zero, only that reference is rejected; other references can still be updated.

===== `post-receive`

The `post-receive` hook runs after the entire process is completed and can be used to update other services or notify users.
It takes the same stdin data as the `pre-receive` hook.
Examples include e-mailing a list, notifying a continuous integration server, or updating a ticket-tracking system – you can even parse the commit messages to see if any tickets need to be opened, modified, or closed.
This script can't stop the push process, but the client doesn't disconnect until it has completed, so be careful if you try to do anything that may take a long time.
