[[_rebasing]]
=== Reorganizar el Trabajo Realizado

(((rebasing)))
En Git tenemos dos formas de integrar cambios de una rama en otra: la fusión (merge) y la reorganización (rebase).
En esta sección vas a aprender en qué consiste la reorganización, como utilizarla, por qué es una herramienta sorprendente y en qué casos no es conveniente utilizarla.

==== Reorganización Básica

Volviendo al ejemplo anterior, en la sección sobre fusiones <<_basic_merging>>, puedes ver que has separado tu trabajo y realizado confirmaciones (commit) en dos ramas diferentes.

.El registro de confirmaciones inicial
image::images/basic-rebase-1.png[El registro de confirmaciones inicial.]

La manera más sencilla de integrar ramas, tal y como hemos visto, es el comando `git merge`.
Realiza una fusión a tres bandas entre las dos últimas instantáneas de cada rama (C3 y C4) y el ancestro común a ambas (C2); creando una nueva instantánea (snapshot) y la correspondiente confirmación (commit).

.Fusionar una rama para integrar el registro de trabajos divergentes
image::images/basic-rebase-2.png[Fusionar una rama para integrar el registro de trabajos divergentes.]

Sin embargo, también hay otra forma de hacerlo: puedes coger los cambios introducidos en C3 y reaplicarlos encima de C4.
Esto es lo que en Git llamamos _reorganizar_ (_rebasing_, en inglés).
Con el comando `git rebase`, puedes coger todos los cambios confirmados en una rama, y reaplicarlos sobre otra.(((git commands, rebase)))

Por ejemplo, puedes lanzar los comandos:

[source,console]
----
$ git checkout experiment
$ git rebase master
First, rewinding head to replay your work on top of it...
Applying: added staged command
----

Haciendo que Git vaya al ancestro común de ambas ramas (donde estás actualmente y de donde quieres reorganizar), saque las diferencias introducidas por cada confirmación en la rama donde estás, guarde esas diferencias en archivos temporales, reinicie (reset) la rama actual hasta llevarla a la misma confirmación en la rama de donde quieres reorganizar, y, finalmente, vuelva a aplicar ordenadamente los cambios.

.Reorganizando sobre C3 los cambios introducidos en C4
image::images/basic-rebase-3.png[Reorganizando sobre C3 los cambios introducidos en C4.]

En este momento, puedes volver a la rama `master` y hacer una fusión con avance rápido (fast-forward merge).

[source,console]
----
$ git checkout master
$ git merge experiment
----

.Avance rápido de la rama `master`
image::images/basic-rebase-4.png[Avance rápido de la rama `master`.]

Así, la instantánea apuntada por `C4'` es exactamente la misma apuntada por `C5` en el ejemplo de la fusión.
No hay ninguna diferencia en el resultado final de la integración, pero el haberla hecho reorganizando nos deja un historial más claro.
Si examinas el historial de una rama reorganizada, este aparece siempre como un historial lineal: como si todo el trabajo se hubiera realizado en series, aunque realmente se haya hecho en paralelo.

Habitualmente, optarás por esta vía cuando quieras estar seguro de que tus confirmaciones de cambio (commits) se pueden aplicar limpiamente sobre una rama remota; posiblemente, en un proyecto donde estés intentando colaborar, pero lleves tu el mantenimiento.
En casos como esos, puedes trabajar sobre una rama y luego reorganizar lo realizado en la rama `origin/master` cuando lo tengas todo listo para enviarlo al proyecto principal.
De esta forma, la persona que mantiene el proyecto no necesitará hacer ninguna integración con tu trabajo; le bastará con un avance rápido o una incorporación limpia.

Cabe destacar que la instantánea (snapshot) apuntada por la confirmación (commit) final, tanto si es producto de una reorganización (rebase) como si lo es de una fusión (merge), es exactamente la misma instantánea; lo único diferente es el historial.
La reorganización vuelve a aplicar cambios de una rama de trabajo sobre otra rama, en el mismo orden en que fueron introducidos en la primera, mientras que la fusión combina entre sí los dos puntos finales de ambas ramas.

==== Algunas Reorganizaciones Interesantes

También puedes aplicar una reorganización (rebase) sobre otra cosa además de sobre la rama de reorganización.
Por ejemplo, considera un historial como el de <<rbdiag_e>>.
Has ramificado a una rama puntual (`server`) para añadir algunas funcionalidades al proyecto, y luego has confirmado los cambios.
Después, vuelves a la rama original para hacer algunos cambios en la parte cliente (rama `client`), y confirmas también esos cambios.
Por último, vuelves sobre la rama `server` y haces algunos cambios más.

[[rbdiag_e]]
.Un historial con una rama puntual sobre otra rama puntual
image::images/interesting-rebase-1.png[Un historial con una rama puntual sobre otra rama puntual.]

Imagina que decides incorporar tus cambios del lado cliente sobre el proyecto principal para hacer un lanzamiento de versión; pero no quieres lanzar aún los cambios del lado servidor porque no están aún suficientemente probados.
Puedes coger los cambios del cliente que no están en server (`C8` y `C9`) y reaplicarlos sobre tu rama principal usando la opción `--onto` del comando `git rebase`:

[source,console]
----
$ git rebase --onto master server client
----

Esto viene a decir: ``Activa la rama `client`, averigua los cambios desde el ancestro común entre las ramas `client` y `server`, y aplicalos en la rama `master`''.
Puede parecer un poco complicado, pero los resultados son realmente interesantes.

.Reorganizando una rama puntual fuera de otra rama puntual
image::images/interesting-rebase-2.png[Reorganizando una rama puntual fuera de otra rama puntual.]

Y, tras esto, ya puedes avanzar la rama principal (ver <<rbdiag_g>>):

[source,console]
----
$ git checkout master
$ git merge client
----

[[rbdiag_g]]
.Avance rápido de tu rama `master`, para incluir los cambios de la rama `client`
image::images/interesting-rebase-3.png[Avance rápido de tu rama `master`, para incluir los cambios de la rama `client`.]

Ahora supongamos que decides traerlos (pull) también sobre tu rama `server`.
Puedes reorganizar (rebase) la rama `server` sobre la rama `master` sin necesidad siquiera de comprobarlo previamente, usando el comando `git rebase [ramabase] [ramapuntual]`, el cual activa la rama puntual (`server` en este caso) y la aplica sobre la rama base (`master` en este caso):

[source,console]
----
$ git rebase master server
----

Esto vuelca el trabajo de `server` sobre el de `master`, tal y como se muestra en <<rbdiag_h>>.

[[rbdiag_h]]
.Reorganizando la rama `server` sobre la rama `master`
image::images/interesting-rebase-4.png[Reorganizando la rama `server` sobre la rama `master`.]

Después, puedes avanzar rápidamente la rama base (`master`):

[source,console]
----
$ git checkout master
$ git merge server
----

Y por último puedes eliminar las ramas `client` y `server` porque ya todo su contenido ha sido integrado y no las vas a necesitar más, dejando tu registro tras todo este proceso tal y como se muestra en <<rbdiag_i>>:

[source,console]
----
$ git branch -d client
$ git branch -d server
----

[[rbdiag_i]]
.Historial final de confirmaciones de cambio
image::images/interesting-rebase-5.png[Historial final de confirmaciones de cambio.]

[[_rebase_peril]]
==== Los Peligros de Reorganizar

(((rebasing, perils of)))
Ahh..., pero la dicha de la reorganización no la alcanzamos sin sus contrapartidas, las cuales pueden resumirse en una línea:

**Nunca reorganices confirmaciones de cambio (commits) que hayas enviado (push) a un repositorio público.**

Si sigues esta recomendación, no tendrás problemas.
Pero si no lo haces, la gente te odiará y serás despreciado por tus familiares y amigos.

Cuando reorganizas algo, estás abandonando las confirmaciones de cambio ya creadas y estás creando unas nuevas; que son similares, pero diferentes.
Si envias (push) confirmaciones (commits) a alguna parte, y otros las recogen (pull) de allí; y después vas tú y las reescribes con `git rebase` y las vuelves a enviar (push) de nuevo; tus colaboradores tendrán que refusionar (re-merge) su trabajo  y todo se volverá tremendamente complicado cuando intentes recoger (pull) su trabajo de vuelta sobre el tuyo.

Veamos con un ejemplo como reorganizar trabajo que has hecho público puede causar problemas
Imagínate que haces un clon desde un servidor central, y luego trabajas sobre él.
Tu historial de cambios puede ser algo como esto:

.Clonar un repositorio y trabajar sobre él
image::images/perils-of-rebasing-1.png[Clonar un repositorio y trabajar sobre él.]

Ahora, otra persona trabaja también sobre ello, realiza una fusión (merge) y lleva (push) su trabajo al servidor central.
Tú te traes (fetch) sus trabajos y los fusionas (merge) sobre una nueva rama en tu trabajo, con lo que tu historial quedaría parecido a esto:

.Traer (fetch) algunas confirmaciones de cambio (commits) y fusionarlas (merge) sobre tu trabajo
image::images/perils-of-rebasing-2.png[Traer (fetch) algunas confirmaciones de cambio (commits) y fusionarlas (merge) sobre tu trabajo.]

A continuación, la persona que había llevado cambios al servidor central decide retroceder y reorganizar su trabajo; haciendo un `git push --force` para sobrescribir el registro en el servidor.
Tu te traes (fetch) esos nuevos cambios desde el servidor.

[[_pre_merge_rebase_work]]
.Alguien envií (push) confirmaciones (commits) reorganizadas, abandonando las confirmaciones en las que tu habías basado tu trabajo
image::images/perils-of-rebasing-3.png[Alguien envií (push) confirmaciones (commits) reorganizadas, abandonando las confirmaciones en las que tu habías basado tu trabajo.]

Ahora los dos están en un aprieto.
Si haces `git pull` crearás una fusión confirmada, la cual incluirá ambas líneas del historial, y tu repositorio lucirá así:

[[_merge_rebase_work]]
.Vuelves a fusionar el mismo trabajo en una nueva fusión confirmada
image::images/perils-of-rebasing-4.png[Vuelves a fusionar el mismo trabajo en una nueva fusión confirmada.]

Si ejecutas `git log` sobre un historial así, verás dos confirmaciones hechas por el mismo autor y con la misma fecha y mensaje, lo cual será confuso.
Es más, si luego tu envías (push) ese registro de vuelta al servidor, vas a introducir todas esas confirmaciones reorganizadas en el servidor central.
Lo que puede confundir aún más a la gente.
Era más seguro asumir que el otro desarrollador no quería que `C4`y `C6` estuviesen en el historial; por ello había reorganizado su trabajo de esa manera.

[[_rebase_rebase]]
==== Rebase When You Rebase

If you *do* find yourself in a situation like this, Git has some further magic that might help you out. If someone on your team force pushes changes that overwrite work that you've based work on, your challenge is to figure out what is yours and what they've rewritten.

It turns out that in addition to the commit SHA-1 checksum, Git also calculates a checksum that is based just on the patch introduced with the commit. This is called a ``patch-id''.

If you pull down work that was rewritten and rebase it on top of the new commits from your partner, Git can often successfully figure out what is uniquely yours and apply them back on top of the new branch.

For instance, in the previous scenario, if instead of doing a merge when we're at <<_pre_merge_rebase_work>> we run `git rebase teamone/master`, Git will:

* Determine what work is unique to our branch (C2, C3, C4, C6, C7)
* Determine which are not merge commits (C2, C3, C4)
* Determine which have not been rewritten into the target branch (just C2 and C3, since C4 is the same patch as C4')
* Apply those commits to the top of `teamone/master`

So instead of the result we see in <<_merge_rebase_work>>, we would end up with something more like <<_rebase_rebase_work>>.

[[_rebase_rebase_work]]
.Rebase on top of force-pushed rebase work.
image::images/perils-of-rebasing-5.png[Rebase on top of force-pushed rebase work.]

This only works if C4 and C4' that your partner made are almost exactly the same patch. Otherwise the rebase won't be able to tell that it's a duplicate and will add another C4-like patch (which will probably fail to apply cleanly, since the changes would already be at least somewhat there).

You can also simplify this by running a `git pull --rebase` instead of a normal `git pull`. Or you could do it manually with a `git fetch` followed by a `git rebase teamone/master` in this case.

If you are using `git pull` and want to make `--rebase` the default, you can set the `pull.rebase` config value with something like `git config --global pull.rebase true`.

If you treat rebasing as a way to clean up and work with commits before you push them, and if you only rebase commits that have never been available publicly, then you'll be fine.
If you rebase commits that have already been pushed publicly, and people may have based work on those commits, then you may be in for some frustrating trouble, and the scorn of your teammates.

If you or a partner does find it necessary at some point, make sure everyone knows to run `git pull --rebase` to try to make the pain after it happens a little bit simpler.

==== Rebase vs. Merge

(((rebasing, vs. merging)))(((merging, vs. rebasing)))
Now that you've seen rebasing and merging in action, you may be wondering which one is better.
Before we can answer this, let's step back a bit and talk about what history means.

One point of view on this is that your repository's commit history is a *record of what actually happened.*
It's a historical document, valuable in its own right, and shouldn't be tampered with.
From this angle, changing the commit history is almost blasphemous; you're _lying_ about what actually transpired.
So what if there was a messy series of merge commits?
That's how it happened, and the repository should preserve that for posterity.

The opposing point of view is that the commit history is the *story of how your project was made.*
You wouldn't publish the first draft of a book, and the manual for how to maintain your software deserves careful editing.
This is the camp that uses tools like rebase and filter-branch to tell the story in the way that's best for future readers.

Now, to the question of whether merging or rebasing is better: hopefully you'll see that it's not that simple.
Git is a powerful tool, and allows you to do many things to and with your history, but every team and every project is different.
Now that you know how both of these things work, it's up to you to decide which one is best for your particular situation.

In general the way to get the best of both worlds is to rebase local changes you've made but haven't shared yet before you push them in order to clean up your story, but never rebase anything you've pushed somewhere.
